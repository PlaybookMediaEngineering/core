/* tslint:disable */
/* eslint-disable */
/**
 * Social Service
 * Solomon AI Social Service
 *
 * The version of the OpenAPI document: 0.1
 * Contact: yoanyomba@solomon-ai.co
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AcceptFollowProfileResponse
 */
export interface AcceptFollowProfileResponse {
    /**
     * 
     * @type {boolean}
     * @memberof AcceptFollowProfileResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AccountType = {
    Unspecified: 'ACCOUNT_TYPE_UNSPECIFIED',
    User: 'ACCOUNT_TYPE_USER',
    Community: 'ACCOUNT_TYPE_COMMUNITY'
} as const;

export type AccountType = typeof AccountType[keyof typeof AccountType];


/**
 * 
 * @export
 * @interface Actor
 */
export interface Actor {
    /**
     * 
     * @type {UserProfile}
     * @memberof Actor
     */
    'userProfile': UserProfile;
    /**
     * 
     * @type {CommunityProfile}
     * @memberof Actor
     */
    'community': CommunityProfile;
    /**
     * 
     * @type {AccountType}
     * @memberof Actor
     */
    'actorType': AccountType;
}


/**
 * 
 * @export
 * @interface AddCommentQualityScoreResponse
 */
export interface AddCommentQualityScoreResponse {
    /**
     * 
     * @type {Comment}
     * @memberof AddCommentQualityScoreResponse
     */
    'comment'?: Comment;
}
/**
 * 
 * @export
 * @interface AddPostQualityScoreResponse
 */
export interface AddPostQualityScoreResponse {
    /**
     * 
     * @type {Post}
     * @memberof AddPostQualityScoreResponse
     */
    'regularPost'?: Post;
    /**
     * 
     * @type {SharedPost}
     * @memberof AddPostQualityScoreResponse
     */
    'sharedPost'?: SharedPost;
    /**
     * 
     * @type {PollPost}
     * @memberof AddPostQualityScoreResponse
     */
    'pollPost'?: PollPost;
}
/**
 * 
 * @export
 * @interface AddPostToPublicationResponse
 */
export interface AddPostToPublicationResponse {
    /**
     * 
     * @type {Publication}
     * @memberof AddPostToPublicationResponse
     */
    'publication'?: Publication;
}
/**
 * 
 * @export
 * @interface AddPostToThreadResponse
 */
export interface AddPostToThreadResponse {
    /**
     * 
     * @type {Post}
     * @memberof AddPostToThreadResponse
     */
    'regularPost'?: Post;
    /**
     * 
     * @type {SharedPost}
     * @memberof AddPostToThreadResponse
     */
    'sharedPost'?: SharedPost;
    /**
     * 
     * @type {PollPost}
     * @memberof AddPostToThreadResponse
     */
    'pollPost'?: PollPost;
}
/**
 * 
 * @export
 * @interface AddPublicationEditorResponse
 */
export interface AddPublicationEditorResponse {
    /**
     * 
     * @type {Publication}
     * @memberof AddPublicationEditorResponse
     */
    'publication'?: Publication;
}
/**
 * 
 * @export
 * @interface Any
 */
export interface Any {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Any
     */
    '@type'?: string;
}
/**
 * 
 * @export
 * @interface BaseTimeline
 */
export interface BaseTimeline {
    /**
     * 
     * @type {Array<FeedActivity>}
     * @memberof BaseTimeline
     */
    'activities'?: Array<FeedActivity>;
}
/**
 * 
 * @export
 * @interface BlockUserProfileResponse
 */
export interface BlockUserProfileResponse {
    /**
     * 
     * @type {boolean}
     * @memberof BlockUserProfileResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface Bookmark
 */
export interface Bookmark {
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Bookmark
     */
    'postIds'?: Array<string>;
    /**
     * 
     * @type {Array<Publication>}
     * @memberof Bookmark
     */
    'publications'?: Array<Publication>;
}
/**
 * 
 * @export
 * @interface BookmarkPostResponse
 */
export interface BookmarkPostResponse {
    /**
     * 
     * @type {Bookmark}
     * @memberof BookmarkPostResponse
     */
    'bookmark'?: Bookmark;
}
/**
 * 
 * @export
 * @interface BookmarkPublicationResponse
 */
export interface BookmarkPublicationResponse {
    /**
     * 
     * @type {Bookmark}
     * @memberof BookmarkPublicationResponse
     */
    'bookmark'?: Bookmark;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'backendPlatformUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'profileId'?: string;
    /**
     * 
     * @type {Media}
     * @memberof Comment
     */
    'media'?: Media;
    /**
     * 
     * @type {Array<string>}
     * @memberof Comment
     */
    'mentions'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Comment
     */
    'hashtags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'content'?: string;
    /**
     * 
     * @type {Array<CommentReply>}
     * @memberof Comment
     */
    'replies'?: Array<CommentReply>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Comment
     */
    'extra'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'authorUsername': string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'authorProfileImage': string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'affinityScore'?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'qualityScore'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Comment
     */
    'userIdToAffinityScoreMap'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Comment
     */
    'userIdToReportsMap'?: { [key: string]: string; };
    /**
     * 
     * @type {AccountType}
     * @memberof Comment
     */
    'authorAccountType'?: AccountType;
    /**
     * 
     * @type {{ [key: string]: Reaction; }}
     * @memberof Comment
     */
    'userIdToReactionMap'?: { [key: string]: Reaction; };
    /**
     * 
     * @type {Array<Note>}
     * @memberof Comment
     */
    'notes'?: Array<Note>;
}


/**
 * 
 * @export
 * @interface CommentReply
 */
export interface CommentReply {
    /**
     * 
     * @type {string}
     * @memberof CommentReply
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentReply
     */
    'backendPlatformUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentReply
     */
    'profileId'?: string;
    /**
     * 
     * @type {Media}
     * @memberof CommentReply
     */
    'media'?: Media;
    /**
     * 
     * @type {Array<string>}
     * @memberof CommentReply
     */
    'mentions'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CommentReply
     */
    'hashtags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CommentReply
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentReply
     */
    'content'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CommentReply
     */
    'extra'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CommentReply
     */
    'authorUsername': string;
    /**
     * 
     * @type {string}
     * @memberof CommentReply
     */
    'authorProfileImage': string;
    /**
     * 
     * @type {string}
     * @memberof CommentReply
     */
    'affinityScore'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentReply
     */
    'qualityScore'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CommentReply
     */
    'userIdToAffinityScoreMap'?: { [key: string]: string; };
    /**
     * 
     * @type {AccountType}
     * @memberof CommentReply
     */
    'authorAccountType'?: AccountType;
    /**
     * 
     * @type {{ [key: string]: Reaction; }}
     * @memberof CommentReply
     */
    'userIdToReactionMap'?: { [key: string]: Reaction; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CommentReply
     */
    'userIdToReportsMap'?: { [key: string]: string; };
}


/**
 * 
 * @export
 * @interface CommunityProfile
 */
export interface CommunityProfile {
    /**
     * 
     * @type {string}
     * @memberof CommunityProfile
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommunityProfile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CommunityProfile
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof CommunityProfile
     */
    'private': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CommunityProfile
     */
    'visible': boolean;
    /**
     * 
     * @type {string}
     * @memberof CommunityProfile
     */
    'followers': string;
    /**
     * 
     * @type {string}
     * @memberof CommunityProfile
     */
    'communityRules': string;
    /**
     * 
     * @type {Array<Topic>}
     * @memberof CommunityProfile
     */
    'topics'?: Array<Topic>;
    /**
     * 
     * @type {string}
     * @memberof CommunityProfile
     */
    'notificationFeedTimelineId': string;
    /**
     * 
     * @type {string}
     * @memberof CommunityProfile
     */
    'personalFeedTimelineId': string;
    /**
     * 
     * @type {string}
     * @memberof CommunityProfile
     */
    'newsFeedTimelineId': string;
    /**
     * 
     * @type {string}
     * @memberof CommunityProfile
     */
    'profileImageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof CommunityProfile
     */
    'algoliaId': string;
}
/**
 * 
 * @export
 * @interface ContentInsights
 */
export interface ContentInsights {
    /**
     * 
     * @type {string}
     * @memberof ContentInsights
     */
    'sentenceCount'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentInsights
     */
    'wordCount'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentInsights
     */
    'language'?: string;
    /**
     * 
     * @type {number}
     * @memberof ContentInsights
     */
    'languageConfidence'?: number;
    /**
     * 
     * @type {Array<Entities>}
     * @memberof ContentInsights
     */
    'entities'?: Array<Entities>;
    /**
     * 
     * @type {Sentiment}
     * @memberof ContentInsights
     */
    'sentiment'?: Sentiment;
}
/**
 * 
 * @export
 * @interface CreateCommentReplyBody
 */
export interface CreateCommentReplyBody {
    /**
     * 
     * @type {CommentReply}
     * @memberof CreateCommentReplyBody
     */
    'reply'?: CommentReply;
    /**
     * 
     * @type {PostType}
     * @memberof CreateCommentReplyBody
     */
    'postType': PostType;
}


/**
 * 
 * @export
 * @interface CreateCommentReplyResponse
 */
export interface CreateCommentReplyResponse {
    /**
     * 
     * @type {Comment}
     * @memberof CreateCommentReplyResponse
     */
    'comment'?: Comment;
}
/**
 * 
 * @export
 * @interface CreateCommentResponse
 */
export interface CreateCommentResponse {
    /**
     * 
     * @type {Post}
     * @memberof CreateCommentResponse
     */
    'regularPost'?: Post;
    /**
     * 
     * @type {SharedPost}
     * @memberof CreateCommentResponse
     */
    'sharedPost'?: SharedPost;
    /**
     * 
     * @type {PollPost}
     * @memberof CreateCommentResponse
     */
    'pollPost'?: PollPost;
}
/**
 * 
 * @export
 * @interface CreateCommunityProfileBody
 */
export interface CreateCommunityProfileBody {
    /**
     * 
     * @type {CommunityProfile}
     * @memberof CreateCommunityProfileBody
     */
    'profile': CommunityProfile;
}
/**
 * 
 * @export
 * @interface CreateCommunityProfileResponse
 */
export interface CreateCommunityProfileResponse {
    /**
     * 
     * @type {CommunityProfile}
     * @memberof CreateCommunityProfileResponse
     */
    'profile'?: CommunityProfile;
}
/**
 * 
 * @export
 * @interface CreateNoteBody
 */
export interface CreateNoteBody {
    /**
     * 
     * @type {PostType}
     * @memberof CreateNoteBody
     */
    'postType': PostType;
    /**
     * 
     * @type {Note}
     * @memberof CreateNoteBody
     */
    'note'?: Note;
}


/**
 * 
 * @export
 * @interface CreateNoteResponse
 */
export interface CreateNoteResponse {
    /**
     * 
     * @type {Post}
     * @memberof CreateNoteResponse
     */
    'regularPost'?: Post;
    /**
     * 
     * @type {SharedPost}
     * @memberof CreateNoteResponse
     */
    'sharedPost'?: SharedPost;
    /**
     * 
     * @type {PollPost}
     * @memberof CreateNoteResponse
     */
    'pollPost'?: PollPost;
}
/**
 * 
 * @export
 * @interface CreatePollResponse
 */
export interface CreatePollResponse {
    /**
     * 
     * @type {string}
     * @memberof CreatePollResponse
     */
    'pollId'?: string;
}
/**
 * 
 * @export
 * @interface CreatePostResponse
 */
export interface CreatePostResponse {
    /**
     * 
     * @type {Post}
     * @memberof CreatePostResponse
     */
    'post'?: Post;
}
/**
 * 
 * @export
 * @interface CreatePublicationResponse
 */
export interface CreatePublicationResponse {
    /**
     * 
     * @type {string}
     * @memberof CreatePublicationResponse
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface CreateTopicResponse
 */
export interface CreateTopicResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateTopicResponse
     */
    'topicId'?: string;
}
/**
 * 
 * @export
 * @interface CreateUserProfileRequest
 */
export interface CreateUserProfileRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'userId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateUserProfileRequest
     */
    'idsOfCommunitiesToFollow'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'username': string;
    /**
     * 
     * @type {Array<UserTags>}
     * @memberof CreateUserProfileRequest
     */
    'tags': Array<UserTags>;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserProfileRequest
     */
    'isPrivate'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileRequest
     */
    'profileImageUrl': string;
}
/**
 * 
 * @export
 * @interface CreateUserProfileResponse
 */
export interface CreateUserProfileResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateUserProfileResponse
     */
    'virtualProfileId'?: string;
}
/**
 * 
 * @export
 * @interface DeleteCommentReplyResponse
 */
export interface DeleteCommentReplyResponse {
    /**
     * 
     * @type {Comment}
     * @memberof DeleteCommentReplyResponse
     */
    'comment'?: Comment;
}
/**
 * 
 * @export
 * @interface DeleteCommentResponse
 */
export interface DeleteCommentResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DeleteCommentResponse
     */
    'sucess'?: boolean;
}
/**
 * 
 * @export
 * @interface DeleteCommunityProfileResponse
 */
export interface DeleteCommunityProfileResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DeleteCommunityProfileResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface DeleteNoteResponse
 */
export interface DeleteNoteResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DeleteNoteResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface DeletePollResponse
 */
export interface DeletePollResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DeletePollResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface DeletePostFromPublicationResponse
 */
export interface DeletePostFromPublicationResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DeletePostFromPublicationResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface DeletePostResponse
 */
export interface DeletePostResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DeletePostResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface DeletePublicationEditorResponse
 */
export interface DeletePublicationEditorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DeletePublicationEditorResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface DeletePublicationResponse
 */
export interface DeletePublicationResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DeletePublicationResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface DeleteUserProfileResponse
 */
export interface DeleteUserProfileResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DeleteUserProfileResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface DiscoverProfilesResponse
 */
export interface DiscoverProfilesResponse {
    /**
     * 
     * @type {Array<CommunityProfile>}
     * @memberof DiscoverProfilesResponse
     */
    'communityProfiles'?: Array<CommunityProfile>;
    /**
     * 
     * @type {Array<UserProfile>}
     * @memberof DiscoverProfilesResponse
     */
    'userProfiles'?: Array<UserProfile>;
    /**
     * 
     * @type {Array<Topic>}
     * @memberof DiscoverProfilesResponse
     */
    'topics'?: Array<Topic>;
}
/**
 * 
 * @export
 * @interface EditCommentReplyBody
 */
export interface EditCommentReplyBody {
    /**
     * 
     * @type {CommentReply}
     * @memberof EditCommentReplyBody
     */
    'reply'?: CommentReply;
    /**
     * 
     * @type {PostType}
     * @memberof EditCommentReplyBody
     */
    'postType': PostType;
}


/**
 * 
 * @export
 * @interface EditCommentReplyResponse
 */
export interface EditCommentReplyResponse {
    /**
     * 
     * @type {CommentReply}
     * @memberof EditCommentReplyResponse
     */
    'reply'?: CommentReply;
}
/**
 * 
 * @export
 * @interface EditCommunityProfileRequest
 */
export interface EditCommunityProfileRequest {
    /**
     * 
     * @type {CommunityProfile}
     * @memberof EditCommunityProfileRequest
     */
    'profile': CommunityProfile;
    /**
     * 
     * @type {string}
     * @memberof EditCommunityProfileRequest
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof EditCommunityProfileRequest
     */
    'communityProfileId': string;
}
/**
 * 
 * @export
 * @interface EditCommunityProfileResponse
 */
export interface EditCommunityProfileResponse {
    /**
     * 
     * @type {CommunityProfile}
     * @memberof EditCommunityProfileResponse
     */
    'profile'?: CommunityProfile;
}
/**
 * 
 * @export
 * @interface EditNoteResponse
 */
export interface EditNoteResponse {
    /**
     * 
     * @type {Post}
     * @memberof EditNoteResponse
     */
    'regularPost'?: Post;
    /**
     * 
     * @type {SharedPost}
     * @memberof EditNoteResponse
     */
    'sharedPost'?: SharedPost;
    /**
     * 
     * @type {PollPost}
     * @memberof EditNoteResponse
     */
    'pollPost'?: PollPost;
}
/**
 * 
 * @export
 * @interface EditPostResponse
 */
export interface EditPostResponse {
    /**
     * 
     * @type {boolean}
     * @memberof EditPostResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface EditUserProfileResponse
 */
export interface EditUserProfileResponse {
    /**
     * 
     * @type {UserProfile}
     * @memberof EditUserProfileResponse
     */
    'profile'?: UserProfile;
}
/**
 * 
 * @export
 * @interface Entities
 */
export interface Entities {
    /**
     * 
     * @type {string}
     * @memberof Entities
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof Entities
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ErrorCode = {
    NoError: 'no_error',
    ValidationError: 'validation_error',
    AuthorizationModelNotFound: 'authorization_model_not_found',
    AuthorizationModelResolutionTooComplex: 'authorization_model_resolution_too_complex',
    InvalidWriteInput: 'invalid_write_input',
    CannotAllowDuplicateTuplesInOneRequest: 'cannot_allow_duplicate_tuples_in_one_request',
    CannotAllowDuplicateTypesInOneRequest: 'cannot_allow_duplicate_types_in_one_request',
    CannotAllowMultipleReferencesToOneRelation: 'cannot_allow_multiple_references_to_one_relation',
    InvalidContinuationToken: 'invalid_continuation_token',
    InvalidTupleSet: 'invalid_tuple_set',
    InvalidCheckInput: 'invalid_check_input',
    InvalidExpandInput: 'invalid_expand_input',
    UnsupportedUserSet: 'unsupported_user_set',
    InvalidObjectFormat: 'invalid_object_format',
    WriteFailedDueToInvalidInput: 'write_failed_due_to_invalid_input',
    AuthorizationModelAssertionsNotFound: 'authorization_model_assertions_not_found',
    LatestAuthorizationModelNotFound: 'latest_authorization_model_not_found',
    TypeNotFound: 'type_not_found',
    RelationNotFound: 'relation_not_found',
    EmptyRelationDefinition: 'empty_relation_definition',
    InvalidUser: 'invalid_user',
    InvalidTuple: 'invalid_tuple',
    UnknownRelation: 'unknown_relation',
    StoreIdInvalidLength: 'store_id_invalid_length',
    AssertionsTooManyItems: 'assertions_too_many_items',
    IdTooLong: 'id_too_long',
    AuthorizationModelIdTooLong: 'authorization_model_id_too_long',
    TupleKeyValueNotSpecified: 'tuple_key_value_not_specified',
    TupleKeysTooManyOrTooFewItems: 'tuple_keys_too_many_or_too_few_items',
    PageSizeInvalid: 'page_size_invalid',
    ParamMissingValue: 'param_missing_value',
    DifferenceBaseMissingValue: 'difference_base_missing_value',
    SubtractBaseMissingValue: 'subtract_base_missing_value',
    ObjectTooLong: 'object_too_long',
    RelationTooLong: 'relation_too_long',
    TypeDefinitionsTooFewItems: 'type_definitions_too_few_items',
    TypeInvalidLength: 'type_invalid_length',
    TypeInvalidPattern: 'type_invalid_pattern',
    RelationsTooFewItems: 'relations_too_few_items',
    RelationsTooLong: 'relations_too_long',
    RelationsInvalidPattern: 'relations_invalid_pattern',
    ObjectInvalidPattern: 'object_invalid_pattern',
    QueryStringTypeContinuationTokenMismatch: 'query_string_type_continuation_token_mismatch',
    ExceededEntityLimit: 'exceeded_entity_limit',
    InvalidContextualTuple: 'invalid_contextual_tuple',
    DuplicateContextualTuple: 'duplicate_contextual_tuple',
    InvalidAuthorizationModel: 'invalid_authorization_model',
    UnsupportedSchemaVersion: 'unsupported_schema_version'
} as const;

export type ErrorCode = typeof ErrorCode[keyof typeof ErrorCode];


/**
 * 
 * @export
 * @interface FeedActivity
 */
export interface FeedActivity {
    /**
     * 
     * @type {Actor}
     * @memberof FeedActivity
     */
    'actor': Actor;
    /**
     * 
     * @type {PostType}
     * @memberof FeedActivity
     */
    'verb'?: PostType;
    /**
     * 
     * @type {Post}
     * @memberof FeedActivity
     */
    'regularPost'?: Post;
    /**
     * 
     * @type {SharedPost}
     * @memberof FeedActivity
     */
    'sharedPost'?: SharedPost;
    /**
     * 
     * @type {PollPost}
     * @memberof FeedActivity
     */
    'pollPost'?: PollPost;
    /**
     * 
     * @type {string}
     * @memberof FeedActivity
     */
    'foreignId'?: string;
    /**
     * Object Describes the target of the activity. The precise meaning of the activity\'s target is dependent on the activities verb, but will often be the object the English preposition \"to\". For instance, in the activity, \"John saved a movie to his wishlist\", the target of the activity is \"wishlist\".
     * @type {string}
     * @memberof FeedActivity
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeedActivity
     */
    'time'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeedActivity
     */
    'origin'?: string;
    /**
     * The TO field allows you to specify a list of feeds to which the activity should be copied. One way to think about it is as the CC functionality of email.
     * @type {Array<string>}
     * @memberof FeedActivity
     */
    'to'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FeedActivity
     */
    'score'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof FeedActivity
     */
    'extra'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof FeedActivity
     */
    'getstreamActivityId': string;
}


/**
 * FeedType encompasses the various types of feeds a profile can have (in conjuction) with getstream.   - FEED_TYPE_PERSONAL: UserFeed is a profile\'s personal feed  - FEED_TYPE_NEWS: NewsFeed is a profile\'s timeline  - FEED_TYPE_NOTIFICATION: NotificationFeed encompasses a profile\'s notification feed
 * @export
 * @enum {string}
 */

export const FeedType = {
    Unspecified: 'FEED_TYPE_UNSPECIFIED',
    Personal: 'FEED_TYPE_PERSONAL',
    News: 'FEED_TYPE_NEWS',
    Notification: 'FEED_TYPE_NOTIFICATION'
} as const;

export type FeedType = typeof FeedType[keyof typeof FeedType];


/**
 * 
 * @export
 * @interface FollowCommunityProfileResponse
 */
export interface FollowCommunityProfileResponse {
    /**
     * 
     * @type {boolean}
     * @memberof FollowCommunityProfileResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface FollowProfileResponse
 */
export interface FollowProfileResponse {
    /**
     * 
     * @type {boolean}
     * @memberof FollowProfileResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface GetAccountsFollowingResponse
 */
export interface GetAccountsFollowingResponse {
    /**
     * 
     * @type {Array<UserProfile>}
     * @memberof GetAccountsFollowingResponse
     */
    'users'?: Array<UserProfile>;
    /**
     * 
     * @type {Array<CommunityProfile>}
     * @memberof GetAccountsFollowingResponse
     */
    'communities'?: Array<CommunityProfile>;
}
/**
 * 
 * @export
 * @interface GetBlogPostsByTagResponse
 */
export interface GetBlogPostsByTagResponse {
    /**
     * 
     * @type {Array<Post>}
     * @memberof GetBlogPostsByTagResponse
     */
    'posts'?: Array<Post>;
}
/**
 * 
 * @export
 * @interface GetBookmarkedPostsResponse
 */
export interface GetBookmarkedPostsResponse {
    /**
     * 
     * @type {Array<Post>}
     * @memberof GetBookmarkedPostsResponse
     */
    'posts'?: Array<Post>;
}
/**
 * 
 * @export
 * @interface GetCommentRepliesResponse
 */
export interface GetCommentRepliesResponse {
    /**
     * 
     * @type {Array<CommentReply>}
     * @memberof GetCommentRepliesResponse
     */
    'replies'?: Array<CommentReply>;
}
/**
 * 
 * @export
 * @interface GetCommunitiesUserFollowsResponse
 */
export interface GetCommunitiesUserFollowsResponse {
    /**
     * 
     * @type {Array<CommunityProfile>}
     * @memberof GetCommunitiesUserFollowsResponse
     */
    'communities'?: Array<CommunityProfile>;
}
/**
 * 
 * @export
 * @interface GetCommunityBlogPostsResponse
 */
export interface GetCommunityBlogPostsResponse {
    /**
     * 
     * @type {Array<Post>}
     * @memberof GetCommunityBlogPostsResponse
     */
    'posts'?: Array<Post>;
}
/**
 * 
 * @export
 * @interface GetCommunityFeedResponse
 */
export interface GetCommunityFeedResponse {
    /**
     * 
     * @type {BaseTimeline}
     * @memberof GetCommunityFeedResponse
     */
    'baseTimeline'?: BaseTimeline;
    /**
     * 
     * @type {NotificationTimeline}
     * @memberof GetCommunityFeedResponse
     */
    'notificationTimeline'?: NotificationTimeline;
    /**
     * 
     * @type {string}
     * @memberof GetCommunityFeedResponse
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface GetCommunityProfileResponse
 */
export interface GetCommunityProfileResponse {
    /**
     * 
     * @type {CommunityProfile}
     * @memberof GetCommunityProfileResponse
     */
    'profile'?: CommunityProfile;
    /**
     * 
     * @type {SocialRelationshipMetadata}
     * @memberof GetCommunityProfileResponse
     */
    'metadata'?: SocialRelationshipMetadata;
}
/**
 * 
 * @export
 * @interface GetCommunityProfilesResponse
 */
export interface GetCommunityProfilesResponse {
    /**
     * 
     * @type {number}
     * @memberof GetCommunityProfilesResponse
     */
    'nextPageNumber'?: number;
    /**
     * 
     * @type {Array<CommunityProfile>}
     * @memberof GetCommunityProfilesResponse
     */
    'profiles'?: Array<CommunityProfile>;
}
/**
 * 
 * @export
 * @interface GetFollowersResponse
 */
export interface GetFollowersResponse {
    /**
     * 
     * @type {Array<UserProfile>}
     * @memberof GetFollowersResponse
     */
    'users'?: Array<UserProfile>;
}
/**
 * 
 * @export
 * @interface GetPendingFollowsResponse
 */
export interface GetPendingFollowsResponse {
    /**
     * 
     * @type {Array<PendingFollowRequest>}
     * @memberof GetPendingFollowsResponse
     */
    'requests'?: Array<PendingFollowRequest>;
}
/**
 * 
 * @export
 * @interface GetPollResponse
 */
export interface GetPollResponse {
    /**
     * 
     * @type {PollPost}
     * @memberof GetPollResponse
     */
    'poll'?: PollPost;
}
/**
 * 
 * @export
 * @interface GetPollsResponse
 */
export interface GetPollsResponse {
    /**
     * 
     * @type {Array<PollPost>}
     * @memberof GetPollsResponse
     */
    'polls'?: Array<PollPost>;
}
/**
 * 
 * @export
 * @interface GetPostResponse
 */
export interface GetPostResponse {
    /**
     * 
     * @type {Post}
     * @memberof GetPostResponse
     */
    'post'?: Post;
}
/**
 * 
 * @export
 * @interface GetPostThreadResponse
 */
export interface GetPostThreadResponse {
    /**
     * 
     * @type {Array<Post>}
     * @memberof GetPostThreadResponse
     */
    'posts'?: Array<Post>;
}
/**
 * 
 * @export
 * @interface GetPostsByTopicResponse
 */
export interface GetPostsByTopicResponse {
    /**
     * 
     * @type {Array<Post>}
     * @memberof GetPostsByTopicResponse
     */
    'posts'?: Array<Post>;
}
/**
 * 
 * @export
 * @interface GetPublicationResponse
 */
export interface GetPublicationResponse {
    /**
     * 
     * @type {Publication}
     * @memberof GetPublicationResponse
     */
    'publication'?: Publication;
}
/**
 * 
 * @export
 * @interface GetTopicsOfCommunitiesUserFollowsResponse
 */
export interface GetTopicsOfCommunitiesUserFollowsResponse {
    /**
     * 
     * @type {Array<Topic>}
     * @memberof GetTopicsOfCommunitiesUserFollowsResponse
     */
    'topic'?: Array<Topic>;
}
/**
 * 
 * @export
 * @interface GetUserFeedResponse
 */
export interface GetUserFeedResponse {
    /**
     * 
     * @type {BaseTimeline}
     * @memberof GetUserFeedResponse
     */
    'baseTimeline'?: BaseTimeline;
    /**
     * 
     * @type {NotificationTimeline}
     * @memberof GetUserFeedResponse
     */
    'notificationTimeline'?: NotificationTimeline;
    /**
     * 
     * @type {string}
     * @memberof GetUserFeedResponse
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface GetUserProfileResponse
 */
export interface GetUserProfileResponse {
    /**
     * 
     * @type {UserProfile}
     * @memberof GetUserProfileResponse
     */
    'profile'?: UserProfile;
    /**
     * 
     * @type {SocialRelationshipMetadata}
     * @memberof GetUserProfileResponse
     */
    'metadata'?: SocialRelationshipMetadata;
}
/**
 * 
 * @export
 * @interface GetUserProfilesResponse
 */
export interface GetUserProfilesResponse {
    /**
     * 
     * @type {number}
     * @memberof GetUserProfilesResponse
     */
    'nextPageNumber'?: number;
    /**
     * 
     * @type {Array<UserProfile>}
     * @memberof GetUserProfilesResponse
     */
    'profiles'?: Array<UserProfile>;
}
/**
 * 
 * @export
 * @interface HealthCheckResponse
 */
export interface HealthCheckResponse {
    /**
     * 
     * @type {boolean}
     * @memberof HealthCheckResponse
     */
    'healthy'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const InternalErrorCode = {
    NoInternalError: 'no_internal_error',
    InternalError: 'internal_error',
    Cancelled: 'cancelled',
    DeadlineExceeded: 'deadline_exceeded',
    AlreadyExists: 'already_exists',
    ResourceExhausted: 'resource_exhausted',
    FailedPrecondition: 'failed_precondition',
    Aborted: 'aborted',
    OutOfRange: 'out_of_range',
    Unavailable: 'unavailable',
    DataLoss: 'data_loss'
} as const;

export type InternalErrorCode = typeof InternalErrorCode[keyof typeof InternalErrorCode];


/**
 * 
 * @export
 * @interface InternalErrorMessageResponse
 */
export interface InternalErrorMessageResponse {
    /**
     * 
     * @type {InternalErrorCode}
     * @memberof InternalErrorMessageResponse
     */
    'code'?: InternalErrorCode;
    /**
     * 
     * @type {string}
     * @memberof InternalErrorMessageResponse
     */
    'message'?: string;
}


/**
 * 
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'link'?: string;
    /**
     * 
     * @type {MediaMetadata}
     * @memberof Media
     */
    'metadata'?: MediaMetadata;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MediaCrop = {
    Unspecified: 'MEDIA_CROP_UNSPECIFIED',
    Top: 'MEDIA_CROP_TOP',
    Bottom: 'MEDIA_CROP_BOTTOM',
    Left: 'MEDIA_CROP_LEFT',
    Right: 'MEDIA_CROP_RIGHT',
    Center: 'MEDIA_CROP_CENTER'
} as const;

export type MediaCrop = typeof MediaCrop[keyof typeof MediaCrop];


/**
 * 
 * @export
 * @interface MediaMetadata
 */
export interface MediaMetadata {
    /**
     * 
     * @type {string}
     * @memberof MediaMetadata
     */
    'id'?: string;
    /**
     * 
     * @type {MediaResize}
     * @memberof MediaMetadata
     */
    'resize'?: MediaResize;
    /**
     * 
     * @type {MediaCrop}
     * @memberof MediaMetadata
     */
    'crop'?: MediaCrop;
    /**
     * 
     * @type {string}
     * @memberof MediaMetadata
     */
    'imageWidth'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaMetadata
     */
    'imageHeight'?: string;
    /**
     * 
     * @type {MediaType}
     * @memberof MediaMetadata
     */
    'type'?: MediaType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const MediaResize = {
    Unspecified: 'MEDIA_RESIZE_UNSPECIFIED',
    Clip: 'MEDIA_RESIZE_CLIP',
    Crop: 'MEDIA_RESIZE_CROP',
    Scale: 'MEDIA_RESIZE_SCALE'
} as const;

export type MediaResize = typeof MediaResize[keyof typeof MediaResize];


/**
 * 
 * @export
 * @enum {string}
 */

export const MediaType = {
    Unspecified: 'MEDIA_TYPE_UNSPECIFIED',
    Image: 'MEDIA_TYPE_IMAGE',
    Video: 'MEDIA_TYPE_VIDEO'
} as const;

export type MediaType = typeof MediaType[keyof typeof MediaType];


/**
 * 
 * @export
 * @enum {string}
 */

export const NotFoundErrorCode = {
    NoNotFoundError: 'no_not_found_error',
    UndefinedEndpoint: 'undefined_endpoint',
    StoreIdNotFound: 'store_id_not_found',
    Unimplemented: 'unimplemented'
} as const;

export type NotFoundErrorCode = typeof NotFoundErrorCode[keyof typeof NotFoundErrorCode];


/**
 * 
 * @export
 * @interface Note
 */
export interface Note {
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'backendPlatformUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'profileId'?: string;
    /**
     * 
     * @type {Media}
     * @memberof Note
     */
    'media'?: Media;
    /**
     * 
     * @type {Array<string>}
     * @memberof Note
     */
    'mentions'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Note
     */
    'hashtags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'content': string;
    /**
     * 
     * @type {AccountType}
     * @memberof Note
     */
    'authorAccountType'?: AccountType;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'authorUserName': string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'authorProfileImage': string;
}


/**
 * 
 * @export
 * @interface NotificationActivity
 */
export interface NotificationActivity {
    /**
     * 
     * @type {string}
     * @memberof NotificationActivity
     */
    'actorName'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationActivity
     */
    'foreignId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationActivity
     */
    'activityId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationActivity
     */
    'verb'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationActivity
     */
    'time'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationActivity
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationActivity
     */
    'origin'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationActivity
     */
    'object'?: string;
}
/**
 * 
 * @export
 * @interface NotificationFeedGroup
 */
export interface NotificationFeedGroup {
    /**
     * 
     * @type {string}
     * @memberof NotificationFeedGroup
     */
    'activityCount'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationFeedGroup
     */
    'actorCount'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationFeedGroup
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationFeedGroup
     */
    'group'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationFeedGroup
     */
    'feedGroupId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationFeedGroup
     */
    'isRead'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationFeedGroup
     */
    'isSeen'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationFeedGroup
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationFeedGroup
     */
    'verb'?: string;
    /**
     * 
     * @type {Array<NotificationActivity>}
     * @memberof NotificationFeedGroup
     */
    'activities'?: Array<NotificationActivity>;
}
/**
 * 
 * @export
 * @interface NotificationTimeline
 */
export interface NotificationTimeline {
    /**
     * 
     * @type {Array<NotificationFeedGroup>}
     * @memberof NotificationTimeline
     */
    'activities'?: Array<NotificationFeedGroup>;
}
/**
 * 
 * @export
 * @interface PathUnknownErrorMessageResponse
 */
export interface PathUnknownErrorMessageResponse {
    /**
     * 
     * @type {NotFoundErrorCode}
     * @memberof PathUnknownErrorMessageResponse
     */
    'code'?: NotFoundErrorCode;
    /**
     * 
     * @type {string}
     * @memberof PathUnknownErrorMessageResponse
     */
    'message'?: string;
}


/**
 * 
 * @export
 * @interface PendingFollowRequest
 */
export interface PendingFollowRequest {
    /**
     * 
     * @type {string}
     * @memberof PendingFollowRequest
     */
    'followRequestId'?: string;
    /**
     * 
     * @type {UserProfile}
     * @memberof PendingFollowRequest
     */
    'followerRequestionToFollow': UserProfile;
    /**
     * 
     * @type {string}
     * @memberof PendingFollowRequest
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface PollPost
 */
export interface PollPost {
    /**
     * 
     * @type {string}
     * @memberof PollPost
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PollPost
     */
    'createdAt'?: string;
    /**
     * 
     * @type {PostType}
     * @memberof PollPost
     */
    'action': PostType;
    /**
     * 
     * @type {string}
     * @memberof PollPost
     */
    'content': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PollPost
     */
    'mentions'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PollPost
     */
    'hashtags'?: Array<string>;
    /**
     * 
     * @type {Media}
     * @memberof PollPost
     */
    'media'?: Media;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PollPost
     */
    'extra'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<Comment>}
     * @memberof PollPost
     */
    'comments'?: Array<Comment>;
    /**
     * 
     * @type {string}
     * @memberof PollPost
     */
    'backendPlatformUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PollPost
     */
    'profileId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PollPost
     */
    'title'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PollPost
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PollPost
     */
    'topicName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PollPost
     */
    'authorUsername'?: string;
    /**
     * 
     * @type {string}
     * @memberof PollPost
     */
    'authorProfileImage'?: string;
    /**
     * 
     * @type {string}
     * @memberof PollPost
     */
    'affinityScore'?: string;
    /**
     * 
     * @type {string}
     * @memberof PollPost
     */
    'qualityScore'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PollPost
     */
    'userIdToAffinityScoreMap'?: { [key: string]: string; };
    /**
     * 
     * @type {ContentInsights}
     * @memberof PollPost
     */
    'insights'?: ContentInsights;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PollPost
     */
    'userIdToReportsMap'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PollPost
     */
    'backgroundImageUrl'?: string;
    /**
     * 
     * @type {AccountType}
     * @memberof PollPost
     */
    'authorAccountType'?: AccountType;
    /**
     * 
     * @type {{ [key: string]: PollResponse; }}
     * @memberof PollPost
     */
    'userIdToPollResponsesMap'?: { [key: string]: PollResponse; };
    /**
     * 
     * @type {Array<string>}
     * @memberof PollPost
     */
    'pollOptions': Array<string>;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof PollPost
     */
    'pollDistribution'?: { [key: string]: number; };
    /**
     * 
     * @type {string}
     * @memberof PollPost
     */
    'pollEndDate'?: string;
    /**
     * 
     * @type {Array<Note>}
     * @memberof PollPost
     */
    'notes'?: Array<Note>;
    /**
     * 
     * @type {Thread}
     * @memberof PollPost
     */
    'thread'?: Thread;
    /**
     * 
     * @type {ThreadParticipantType}
     * @memberof PollPost
     */
    'threadParticipantType'?: ThreadParticipantType;
    /**
     * 
     * @type {{ [key: string]: Reaction; }}
     * @memberof PollPost
     */
    'userIdToReactionMap'?: { [key: string]: Reaction; };
}


/**
 * 
 * @export
 * @interface PollResponse
 */
export interface PollResponse {
    /**
     * 
     * @type {string}
     * @memberof PollResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PollResponse
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PollResponse
     */
    'responseValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PollResponse
     */
    'responseIdx'?: string;
}
/**
 * 
 * @export
 * @interface Post
 */
export interface Post {
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    'createdAt'?: string;
    /**
     * 
     * @type {PostType}
     * @memberof Post
     */
    'action': PostType;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    'content': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Post
     */
    'mentions'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Post
     */
    'hashtags'?: Array<string>;
    /**
     * 
     * @type {Media}
     * @memberof Post
     */
    'media'?: Media;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Post
     */
    'extra'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<Comment>}
     * @memberof Post
     */
    'comments'?: Array<Comment>;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    'backendPlatformUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    'profileId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    'title'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Post
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    'topicName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    'authorUsername'?: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    'authorProfileImage'?: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    'affinityScore'?: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    'qualityScore'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Post
     */
    'userIdToAffinityScoreMap'?: { [key: string]: string; };
    /**
     * 
     * @type {ContentInsights}
     * @memberof Post
     */
    'insights'?: ContentInsights;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Post
     */
    'userIdToReportsMap'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    'readingTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    'backgroundImageUrl'?: string;
    /**
     * 
     * @type {AccountType}
     * @memberof Post
     */
    'authorAccountType'?: AccountType;
    /**
     * 
     * @type {Array<Note>}
     * @memberof Post
     */
    'notes'?: Array<Note>;
    /**
     * 
     * @type {Thread}
     * @memberof Post
     */
    'thread'?: Thread;
    /**
     * 
     * @type {ThreadParticipantType}
     * @memberof Post
     */
    'threadParticipantType'?: ThreadParticipantType;
    /**
     * 
     * @type {{ [key: string]: Reaction; }}
     * @memberof Post
     */
    'userIdToReactionMap'?: { [key: string]: Reaction; };
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    'aiGeneratedQuestionResponse'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PostType = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;

export type PostType = typeof PostType[keyof typeof PostType];


/**
 * Use Case - An online magazine, a publication with a fixed publication staff that posts stories around a specific topic - A community publication, a publication that accepts stories published around Medium - A company blog, a publication that is created specifically to share company news - A collection of individual stories by a single author that are parts of a larger whole
 * @export
 * @interface Publication
 */
export interface Publication {
    /**
     * 
     * @type {string}
     * @memberof Publication
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Publication
     */
    'postIds'?: Array<string>;
    /**
     * 
     * @type {UserProfile}
     * @memberof Publication
     */
    'admin'?: UserProfile;
    /**
     * 
     * @type {string}
     * @memberof Publication
     */
    'adminBackendPlatformUserId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Publication
     */
    'tags': Array<string>;
    /**
     * 
     * @type {Array<UserProfile>}
     * @memberof Publication
     */
    'editors'?: Array<UserProfile>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Publication
     */
    'subjects': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Publication
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Publication
     */
    'createdAt'?: string;
    /**
     * 
     * @type {PublicationType}
     * @memberof Publication
     */
    'type': PublicationType;
    /**
     * 
     * @type {string}
     * @memberof Publication
     */
    'publicationName': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PublicationType = {
    Unspecified: 'PUBLICATION_TYPE_UNSPECIFIED',
    Magazine: 'PUBLICATION_TYPE_MAGAZINE',
    Platform: 'PUBLICATION_TYPE_PLATFORM',
    Blog: 'PUBLICATION_TYPE_BLOG',
    Subjects: 'PUBLICATION_TYPE_SUBJECTS'
} as const;

export type PublicationType = typeof PublicationType[keyof typeof PublicationType];


/**
 * 
 * @export
 * @interface ReactToCommentReplyResponse
 */
export interface ReactToCommentReplyResponse {
    /**
     * 
     * @type {CommentReply}
     * @memberof ReactToCommentReplyResponse
     */
    'reply'?: CommentReply;
}
/**
 * 
 * @export
 * @interface ReactToCommentResponse
 */
export interface ReactToCommentResponse {
    /**
     * 
     * @type {Comment}
     * @memberof ReactToCommentResponse
     */
    'comment'?: Comment;
}
/**
 * 
 * @export
 * @interface ReactToPostResponse
 */
export interface ReactToPostResponse {
    /**
     * 
     * @type {Post}
     * @memberof ReactToPostResponse
     */
    'regularPost'?: Post;
    /**
     * 
     * @type {SharedPost}
     * @memberof ReactToPostResponse
     */
    'sharedPost'?: SharedPost;
    /**
     * 
     * @type {PollPost}
     * @memberof ReactToPostResponse
     */
    'pollPost'?: PollPost;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Reaction = {
    Unspecified: 'REACTION_UNSPECIFIED',
    Like: 'REACTION_LIKE',
    Love: 'REACTION_LOVE',
    Haha: 'REACTION_HAHA',
    Wow: 'REACTION_WOW',
    Sad: 'REACTION_SAD',
    Angry: 'REACTION_ANGRY',
    Dislike: 'REACTION_DISLIKE'
} as const;

export type Reaction = typeof Reaction[keyof typeof Reaction];


/**
 * 
 * @export
 * @interface ReadynessCheckResponse
 */
export interface ReadynessCheckResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ReadynessCheckResponse
     */
    'ready'?: boolean;
}
/**
 * 
 * @export
 * @interface RemoveBookmarkedPostResponse
 */
export interface RemoveBookmarkedPostResponse {
    /**
     * 
     * @type {Bookmark}
     * @memberof RemoveBookmarkedPostResponse
     */
    'bookmark'?: Bookmark;
}
/**
 * 
 * @export
 * @interface RemoveBookmarkedPublicationResponse
 */
export interface RemoveBookmarkedPublicationResponse {
    /**
     * 
     * @type {Bookmark}
     * @memberof RemoveBookmarkedPublicationResponse
     */
    'bookmark'?: Bookmark;
}
/**
 * 
 * @export
 * @interface RemovePostFromThreadResponse
 */
export interface RemovePostFromThreadResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RemovePostFromThreadResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface ReportCommentBody
 */
export interface ReportCommentBody {
    /**
     * 
     * @type {PostType}
     * @memberof ReportCommentBody
     */
    'postType': PostType;
}


/**
 * 
 * @export
 * @interface ReportCommentReplyBody
 */
export interface ReportCommentReplyBody {
    /**
     * 
     * @type {PostType}
     * @memberof ReportCommentReplyBody
     */
    'postType': PostType;
}


/**
 * 
 * @export
 * @interface ReportCommentReplyResponse
 */
export interface ReportCommentReplyResponse {
    /**
     * 
     * @type {CommentReply}
     * @memberof ReportCommentReplyResponse
     */
    'reply'?: CommentReply;
}
/**
 * 
 * @export
 * @interface ReportCommentResponse
 */
export interface ReportCommentResponse {
    /**
     * 
     * @type {Comment}
     * @memberof ReportCommentResponse
     */
    'comment'?: Comment;
}
/**
 * 
 * @export
 * @interface ReportPostResponse
 */
export interface ReportPostResponse {
    /**
     * 
     * @type {Post}
     * @memberof ReportPostResponse
     */
    'post'?: Post;
}
/**
 * 
 * @export
 * @interface RespondToPollBody
 */
export interface RespondToPollBody {
    /**
     * 
     * @type {string}
     * @memberof RespondToPollBody
     */
    'pollOption': string;
    /**
     * 
     * @type {string}
     * @memberof RespondToPollBody
     */
    'pollOptionIdx': string;
}
/**
 * 
 * @export
 * @interface RespondToPollResponse
 */
export interface RespondToPollResponse {
    /**
     * 
     * @type {PollPost}
     * @memberof RespondToPollResponse
     */
    'poll'?: PollPost;
}
/**
 * 
 * @export
 * @interface Sentiment
 */
export interface Sentiment {
    /**
     * 
     * @type {number}
     * @memberof Sentiment
     */
    'negative'?: number;
    /**
     * 
     * @type {number}
     * @memberof Sentiment
     */
    'neutral'?: number;
    /**
     * 
     * @type {number}
     * @memberof Sentiment
     */
    'positive'?: number;
    /**
     * 
     * @type {number}
     * @memberof Sentiment
     */
    'compound'?: number;
}
/**
 * 
 * @export
 * @interface SharePostResponse
 */
export interface SharePostResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SharePostResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface SharedPost
 */
export interface SharedPost {
    /**
     * 
     * @type {string}
     * @memberof SharedPost
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SharedPost
     */
    'originalPostId': string;
    /**
     * 
     * @type {string}
     * @memberof SharedPost
     */
    'originalAuthorUsername'?: string;
    /**
     * 
     * @type {string}
     * @memberof SharedPost
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof SharedPost
     */
    'content': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SharedPost
     */
    'mentions'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SharedPost
     */
    'hashtags'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SharedPost
     */
    'extra'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<Comment>}
     * @memberof SharedPost
     */
    'comments'?: Array<Comment>;
    /**
     * 
     * @type {string}
     * @memberof SharedPost
     */
    'backendPlatformUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SharedPost
     */
    'profileId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SharedPost
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SharedPost
     */
    'authorUsername'?: string;
    /**
     * 
     * @type {string}
     * @memberof SharedPost
     */
    'affinityScore'?: string;
    /**
     * 
     * @type {string}
     * @memberof SharedPost
     */
    'qualityScore'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SharedPost
     */
    'userIdToAffinityScoreMap'?: { [key: string]: string; };
    /**
     * AccountType is the account type of the creator of this piece of  content
     * @type {{ [key: string]: string; }}
     * @memberof SharedPost
     */
    'userIdToReportsMap'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<Note>}
     * @memberof SharedPost
     */
    'notes'?: Array<Note>;
    /**
     * 
     * @type {Thread}
     * @memberof SharedPost
     */
    'thread'?: Thread;
    /**
     * 
     * @type {AccountType}
     * @memberof SharedPost
     */
    'authorAccountType'?: AccountType;
    /**
     * 
     * @type {{ [key: string]: Reaction; }}
     * @memberof SharedPost
     */
    'userIdToReactionMap'?: { [key: string]: Reaction; };
    /**
     * 
     * @type {PostType}
     * @memberof SharedPost
     */
    'action': PostType;
    /**
     * 
     * @type {string}
     * @memberof SharedPost
     */
    'originalPostUserProfileId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SharedPost
     */
    'originalPostUserbackendPlaformId'?: string;
    /**
     * 
     * @type {PostType}
     * @memberof SharedPost
     */
    'originalPostAction': PostType;
}


/**
 * 
 * @export
 * @interface SocialProfileMetadata
 */
export interface SocialProfileMetadata {
    /**
     * 
     * @type {AccountType}
     * @memberof SocialProfileMetadata
     */
    'profileType'?: AccountType;
    /**
     * 
     * @type {string}
     * @memberof SocialProfileMetadata
     */
    'profileId'?: string;
}


/**
 * 
 * @export
 * @interface SocialRelationshipMetadata
 */
export interface SocialRelationshipMetadata {
    /**
     * 
     * @type {SocialProfileMetadata}
     * @memberof SocialRelationshipMetadata
     */
    'sourceProfile': SocialProfileMetadata;
    /**
     * 
     * @type {SocialProfileMetadata}
     * @memberof SocialRelationshipMetadata
     */
    'targetProfile': SocialProfileMetadata;
    /**
     * 
     * @type {boolean}
     * @memberof SocialRelationshipMetadata
     */
    'following'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SocialRelationshipMetadata
     */
    'followingSince'?: string;
}
/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * 
     * @type {number}
     * @memberof Status
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Any>}
     * @memberof Status
     */
    'details'?: Array<Any>;
}
/**
 * 
 * @export
 * @interface Thread
 */
export interface Thread {
    /**
     * 
     * @type {string}
     * @memberof Thread
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Thread
     */
    'postIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Thread
     */
    'parentPostId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Thread
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Thread
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ThreadParticipantType = {
    Unspecified: 'THREAD_PARTICIPANT_TYPE_UNSPECIFIED',
    Parent: 'THREAD_PARTICIPANT_TYPE_PARENT',
    Participant: 'THREAD_PARTICIPANT_TYPE_PARTICIPANT'
} as const;

export type ThreadParticipantType = typeof ThreadParticipantType[keyof typeof ThreadParticipantType];


/**
 * 
 * @export
 * @interface Topic
 */
export interface Topic {
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'topicName': string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'imageUrl': string;
}
/**
 * 
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'id'?: string;
    /**
     * 
     * @type {Array<UserTags>}
     * @memberof UserProfile
     */
    'tags': Array<UserTags>;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserProfile
     */
    'private': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'followers': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'following': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'notificationFeedTimelineId': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'personalFeedTimelineId': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'newsFeedTimelineId': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'profileImageUrl': string;
    /**
     * 
     * @type {Bookmark}
     * @memberof UserProfile
     */
    'bookmarks': Bookmark;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'algoliaId': string;
}
/**
 * 
 * @export
 * @interface UserTags
 */
export interface UserTags {
    /**
     * 
     * @type {string}
     * @memberof UserTags
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTags
     */
    'tagName': string;
    /**
     * 
     * @type {string}
     * @memberof UserTags
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorMessageResponse
 */
export interface ValidationErrorMessageResponse {
    /**
     * 
     * @type {ErrorCode}
     * @memberof ValidationErrorMessageResponse
     */
    'code'?: ErrorCode;
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorMessageResponse
     */
    'message'?: string;
}



/**
 * BlockProfileApi - axios parameter creator
 * @export
 */
export const BlockProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client to block a user profile
         * @summary blocks a user profile
         * @param {string} sourceUserId the user ID trying to block another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} targetUserId the user ID being blocked by another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockUserProfile: async (sourceUserId: string, targetUserId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUserId' is not null or undefined
            assertParamExists('blockUserProfile', 'sourceUserId', sourceUserId)
            // verify required parameter 'targetUserId' is not null or undefined
            assertParamExists('blockUserProfile', 'targetUserId', targetUserId)
            const localVarPath = `/api/v1/users/source/{sourceUserId}/block/target/{targetUserId}`
                .replace(`{${"sourceUserId"}}`, encodeURIComponent(String(sourceUserId)))
                .replace(`{${"targetUserId"}}`, encodeURIComponent(String(targetUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockProfileApi - functional programming interface
 * @export
 */
export const BlockProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlockProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client to block a user profile
         * @summary blocks a user profile
         * @param {string} sourceUserId the user ID trying to block another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} targetUserId the user ID being blocked by another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockUserProfile(sourceUserId: string, targetUserId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockUserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockUserProfile(sourceUserId, targetUserId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BlockProfileApi.blockUserProfile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * BlockProfileApi - factory interface
 * @export
 */
export const BlockProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlockProfileApiFp(configuration)
    return {
        /**
         * This endpoint enables a client to block a user profile
         * @summary blocks a user profile
         * @param {string} sourceUserId the user ID trying to block another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} targetUserId the user ID being blocked by another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockUserProfile(sourceUserId: string, targetUserId: string, options?: any): AxiosPromise<BlockUserProfileResponse> {
            return localVarFp.blockUserProfile(sourceUserId, targetUserId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlockProfileApi - object-oriented interface
 * @export
 * @class BlockProfileApi
 * @extends {BaseAPI}
 */
export class BlockProfileApi extends BaseAPI {
    /**
     * This endpoint enables a client to block a user profile
     * @summary blocks a user profile
     * @param {string} sourceUserId the user ID trying to block another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {string} targetUserId the user ID being blocked by another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockProfileApi
     */
    public blockUserProfile(sourceUserId: string, targetUserId: string, options?: AxiosRequestConfig) {
        return BlockProfileApiFp(this.configuration).blockUserProfile(sourceUserId, targetUserId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BookmarkApi - axios parameter creator
 * @export
 */
export const BookmarkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client to bookmark a post
         * @summary Bookmarks a post
         * @param {string} userId 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkPost: async (userId: string, postId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('bookmarkPost', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('bookmarkPost', 'postId', postId)
            const localVarPath = `/api/v1/users/{userId}/post/bookmark/{postId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to bookmark a publication
         * @summary Bookmarks a publication
         * @param {string} userId 
         * @param {string} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkPublication: async (userId: string, publicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('bookmarkPublication', 'userId', userId)
            // verify required parameter 'publicationId' is not null or undefined
            assertParamExists('bookmarkPublication', 'publicationId', publicationId)
            const localVarPath = `/api/v1/users/{userId}/publication/{publicationId}/bookmark`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"publicationId"}}`, encodeURIComponent(String(publicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to delete a bookmarked post
         * @summary Deletes A Bookmarked Post
         * @param {string} userId 
         * @param {string} postId 
         * @param {RemoveBookmarkedPostPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBookmarkedPost: async (userId: string, postId: string, postType: RemoveBookmarkedPostPostTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeBookmarkedPost', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('removeBookmarkedPost', 'postId', postId)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('removeBookmarkedPost', 'postType', postType)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/bookmark`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (postType !== undefined) {
                localVarQueryParameter['postType'] = postType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to delete a bookmarked publication
         * @summary Deletes A Bookmarked Publication
         * @param {string} userId 
         * @param {string} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBookmarkedPublication: async (userId: string, publicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeBookmarkedPublication', 'userId', userId)
            // verify required parameter 'publicationId' is not null or undefined
            assertParamExists('removeBookmarkedPublication', 'publicationId', publicationId)
            const localVarPath = `/api/v1/users/{userId}/publication/{publicationId}/bookmark`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"publicationId"}}`, encodeURIComponent(String(publicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookmarkApi - functional programming interface
 * @export
 */
export const BookmarkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookmarkApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client to bookmark a post
         * @summary Bookmarks a post
         * @param {string} userId 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookmarkPost(userId: string, postId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookmarkPost(userId, postId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BookmarkApi.bookmarkPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to bookmark a publication
         * @summary Bookmarks a publication
         * @param {string} userId 
         * @param {string} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookmarkPublication(userId: string, publicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkPublicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookmarkPublication(userId, publicationId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BookmarkApi.bookmarkPublication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to delete a bookmarked post
         * @summary Deletes A Bookmarked Post
         * @param {string} userId 
         * @param {string} postId 
         * @param {RemoveBookmarkedPostPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeBookmarkedPost(userId: string, postId: string, postType: RemoveBookmarkedPostPostTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveBookmarkedPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeBookmarkedPost(userId, postId, postType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BookmarkApi.removeBookmarkedPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to delete a bookmarked publication
         * @summary Deletes A Bookmarked Publication
         * @param {string} userId 
         * @param {string} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeBookmarkedPublication(userId: string, publicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveBookmarkedPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeBookmarkedPublication(userId, publicationId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BookmarkApi.removeBookmarkedPublication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * BookmarkApi - factory interface
 * @export
 */
export const BookmarkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookmarkApiFp(configuration)
    return {
        /**
         * This endpoint enables a client to bookmark a post
         * @summary Bookmarks a post
         * @param {string} userId 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkPost(userId: string, postId: string, options?: any): AxiosPromise<BookmarkPostResponse> {
            return localVarFp.bookmarkPost(userId, postId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to bookmark a publication
         * @summary Bookmarks a publication
         * @param {string} userId 
         * @param {string} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkPublication(userId: string, publicationId: string, options?: any): AxiosPromise<BookmarkPublicationResponse> {
            return localVarFp.bookmarkPublication(userId, publicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to delete a bookmarked post
         * @summary Deletes A Bookmarked Post
         * @param {string} userId 
         * @param {string} postId 
         * @param {RemoveBookmarkedPostPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBookmarkedPost(userId: string, postId: string, postType: RemoveBookmarkedPostPostTypeEnum, options?: any): AxiosPromise<RemoveBookmarkedPostResponse> {
            return localVarFp.removeBookmarkedPost(userId, postId, postType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to delete a bookmarked publication
         * @summary Deletes A Bookmarked Publication
         * @param {string} userId 
         * @param {string} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBookmarkedPublication(userId: string, publicationId: string, options?: any): AxiosPromise<RemoveBookmarkedPostResponse> {
            return localVarFp.removeBookmarkedPublication(userId, publicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookmarkApi - object-oriented interface
 * @export
 * @class BookmarkApi
 * @extends {BaseAPI}
 */
export class BookmarkApi extends BaseAPI {
    /**
     * This endpoint enables a client to bookmark a post
     * @summary Bookmarks a post
     * @param {string} userId 
     * @param {string} postId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarkApi
     */
    public bookmarkPost(userId: string, postId: string, options?: AxiosRequestConfig) {
        return BookmarkApiFp(this.configuration).bookmarkPost(userId, postId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to bookmark a publication
     * @summary Bookmarks a publication
     * @param {string} userId 
     * @param {string} publicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarkApi
     */
    public bookmarkPublication(userId: string, publicationId: string, options?: AxiosRequestConfig) {
        return BookmarkApiFp(this.configuration).bookmarkPublication(userId, publicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to delete a bookmarked post
     * @summary Deletes A Bookmarked Post
     * @param {string} userId 
     * @param {string} postId 
     * @param {RemoveBookmarkedPostPostTypeEnum} postType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarkApi
     */
    public removeBookmarkedPost(userId: string, postId: string, postType: RemoveBookmarkedPostPostTypeEnum, options?: AxiosRequestConfig) {
        return BookmarkApiFp(this.configuration).removeBookmarkedPost(userId, postId, postType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to delete a bookmarked publication
     * @summary Deletes A Bookmarked Publication
     * @param {string} userId 
     * @param {string} publicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarkApi
     */
    public removeBookmarkedPublication(userId: string, publicationId: string, options?: AxiosRequestConfig) {
        return BookmarkApiFp(this.configuration).removeBookmarkedPublication(userId, publicationId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RemoveBookmarkedPostPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type RemoveBookmarkedPostPostTypeEnum = typeof RemoveBookmarkedPostPostTypeEnum[keyof typeof RemoveBookmarkedPostPostTypeEnum];


/**
 * BookmarksApi - axios parameter creator
 * @export
 */
export const BookmarksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client to get all bookmarked posts of a given user
         * @summary Get Bookmarked Posts
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarkedPosts: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getBookmarkedPosts', 'userId', userId)
            const localVarPath = `/api/v1/users/bookmarks/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookmarksApi - functional programming interface
 * @export
 */
export const BookmarksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookmarksApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client to get all bookmarked posts of a given user
         * @summary Get Bookmarked Posts
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookmarkedPosts(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBookmarkedPostsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBookmarkedPosts(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BookmarksApi.getBookmarkedPosts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * BookmarksApi - factory interface
 * @export
 */
export const BookmarksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookmarksApiFp(configuration)
    return {
        /**
         * This endpoint enables a client to get all bookmarked posts of a given user
         * @summary Get Bookmarked Posts
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarkedPosts(userId: string, options?: any): AxiosPromise<GetBookmarkedPostsResponse> {
            return localVarFp.getBookmarkedPosts(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookmarksApi - object-oriented interface
 * @export
 * @class BookmarksApi
 * @extends {BaseAPI}
 */
export class BookmarksApi extends BaseAPI {
    /**
     * This endpoint enables a client to get all bookmarked posts of a given user
     * @summary Get Bookmarked Posts
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarksApi
     */
    public getBookmarkedPosts(userId: string, options?: AxiosRequestConfig) {
        return BookmarksApiFp(this.configuration).getBookmarkedPosts(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CommentApi - axios parameter creator
 * @export
 */
export const CommentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client to add a quality score to a comment
         * @summary Add Comment Quality Score
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {AddCommentQualityScorePostTypeEnum} postType The type of post being reacted to | type: string
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCommentQualityScore: async (userId: string, postId: string, commentId: string, postType: AddCommentQualityScorePostTypeEnum, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addCommentQualityScore', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('addCommentQualityScore', 'postId', postId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('addCommentQualityScore', 'commentId', commentId)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('addCommentQualityScore', 'postType', postType)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addCommentQualityScore', 'body', body)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/comment/{commentId}/quality`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (postType !== undefined) {
                localVarQueryParameter['postType'] = postType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to create a comment
         * @summary Create A Commnet
         * @param {string} userId the user ID trying to create a comment (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} postId The ID of the post to whom to add the comment | type: string
         * @param {CreateCommentAccountTypeEnum} accountType The type of account making the request to create a comment | type: string
         * @param {CreateCommentPostTypeEnum} postType The type of post being reacted to | type: string
         * @param {Comment} comment The actual comment payload | type: json_object
         * @param {string} [communityProfileId] The ID of the community trying to create a comment | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment: async (userId: string, postId: string, accountType: CreateCommentAccountTypeEnum, postType: CreateCommentPostTypeEnum, comment: Comment, communityProfileId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createComment', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('createComment', 'postId', postId)
            // verify required parameter 'accountType' is not null or undefined
            assertParamExists('createComment', 'accountType', accountType)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('createComment', 'postType', postType)
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('createComment', 'comment', comment)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/comment`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (communityProfileId !== undefined) {
                localVarQueryParameter['communityProfileId'] = communityProfileId;
            }

            if (accountType !== undefined) {
                localVarQueryParameter['accountType'] = accountType;
            }

            if (postType !== undefined) {
                localVarQueryParameter['postType'] = postType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(comment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to delete a comment
         * @summary Delete A Comment
         * @param {string} postId The ID of the post trying to be deleted | type: string
         * @param {string} commentId The ID of the comment trying to be delete | type: string
         * @param {DeleteCommentPostTypeEnum} postType The type of post being reacted to | type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment: async (postId: string, commentId: string, postType: DeleteCommentPostTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('deleteComment', 'postId', postId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('deleteComment', 'commentId', commentId)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('deleteComment', 'postType', postType)
            const localVarPath = `/api/v1/post/{postId}/comment/{commentId}`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (postType !== undefined) {
                localVarQueryParameter['postType'] = postType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to report a comment
         * @summary Report A Comment
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {ReportCommentBody} reportCommentBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportComment: async (userId: string, postId: string, commentId: string, reportCommentBody: ReportCommentBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('reportComment', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('reportComment', 'postId', postId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('reportComment', 'commentId', commentId)
            // verify required parameter 'reportCommentBody' is not null or undefined
            assertParamExists('reportComment', 'reportCommentBody', reportCommentBody)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/comment/{commentId}/report`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportCommentBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentApi - functional programming interface
 * @export
 */
export const CommentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client to add a quality score to a comment
         * @summary Add Comment Quality Score
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {AddCommentQualityScorePostTypeEnum} postType The type of post being reacted to | type: string
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCommentQualityScore(userId: string, postId: string, commentId: string, postType: AddCommentQualityScorePostTypeEnum, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddCommentQualityScoreResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCommentQualityScore(userId, postId, commentId, postType, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CommentApi.addCommentQualityScore']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to create a comment
         * @summary Create A Commnet
         * @param {string} userId the user ID trying to create a comment (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} postId The ID of the post to whom to add the comment | type: string
         * @param {CreateCommentAccountTypeEnum} accountType The type of account making the request to create a comment | type: string
         * @param {CreateCommentPostTypeEnum} postType The type of post being reacted to | type: string
         * @param {Comment} comment The actual comment payload | type: json_object
         * @param {string} [communityProfileId] The ID of the community trying to create a comment | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createComment(userId: string, postId: string, accountType: CreateCommentAccountTypeEnum, postType: CreateCommentPostTypeEnum, comment: Comment, communityProfileId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCommentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createComment(userId, postId, accountType, postType, comment, communityProfileId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CommentApi.createComment']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to delete a comment
         * @summary Delete A Comment
         * @param {string} postId The ID of the post trying to be deleted | type: string
         * @param {string} commentId The ID of the comment trying to be delete | type: string
         * @param {DeleteCommentPostTypeEnum} postType The type of post being reacted to | type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteComment(postId: string, commentId: string, postType: DeleteCommentPostTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCommentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteComment(postId, commentId, postType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CommentApi.deleteComment']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to report a comment
         * @summary Report A Comment
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {ReportCommentBody} reportCommentBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportComment(userId: string, postId: string, commentId: string, reportCommentBody: ReportCommentBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportCommentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportComment(userId, postId, commentId, reportCommentBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CommentApi.reportComment']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CommentApi - factory interface
 * @export
 */
export const CommentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentApiFp(configuration)
    return {
        /**
         * This endpoint enables a client to add a quality score to a comment
         * @summary Add Comment Quality Score
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {AddCommentQualityScorePostTypeEnum} postType The type of post being reacted to | type: string
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCommentQualityScore(userId: string, postId: string, commentId: string, postType: AddCommentQualityScorePostTypeEnum, body: string, options?: any): AxiosPromise<AddCommentQualityScoreResponse> {
            return localVarFp.addCommentQualityScore(userId, postId, commentId, postType, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to create a comment
         * @summary Create A Commnet
         * @param {string} userId the user ID trying to create a comment (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} postId The ID of the post to whom to add the comment | type: string
         * @param {CreateCommentAccountTypeEnum} accountType The type of account making the request to create a comment | type: string
         * @param {CreateCommentPostTypeEnum} postType The type of post being reacted to | type: string
         * @param {Comment} comment The actual comment payload | type: json_object
         * @param {string} [communityProfileId] The ID of the community trying to create a comment | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(userId: string, postId: string, accountType: CreateCommentAccountTypeEnum, postType: CreateCommentPostTypeEnum, comment: Comment, communityProfileId?: string, options?: any): AxiosPromise<CreateCommentResponse> {
            return localVarFp.createComment(userId, postId, accountType, postType, comment, communityProfileId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to delete a comment
         * @summary Delete A Comment
         * @param {string} postId The ID of the post trying to be deleted | type: string
         * @param {string} commentId The ID of the comment trying to be delete | type: string
         * @param {DeleteCommentPostTypeEnum} postType The type of post being reacted to | type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(postId: string, commentId: string, postType: DeleteCommentPostTypeEnum, options?: any): AxiosPromise<CreateCommentResponse> {
            return localVarFp.deleteComment(postId, commentId, postType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to report a comment
         * @summary Report A Comment
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {ReportCommentBody} reportCommentBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportComment(userId: string, postId: string, commentId: string, reportCommentBody: ReportCommentBody, options?: any): AxiosPromise<ReportCommentResponse> {
            return localVarFp.reportComment(userId, postId, commentId, reportCommentBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentApi - object-oriented interface
 * @export
 * @class CommentApi
 * @extends {BaseAPI}
 */
export class CommentApi extends BaseAPI {
    /**
     * This endpoint enables a client to add a quality score to a comment
     * @summary Add Comment Quality Score
     * @param {string} userId 
     * @param {string} postId 
     * @param {string} commentId 
     * @param {AddCommentQualityScorePostTypeEnum} postType The type of post being reacted to | type: string
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public addCommentQualityScore(userId: string, postId: string, commentId: string, postType: AddCommentQualityScorePostTypeEnum, body: string, options?: AxiosRequestConfig) {
        return CommentApiFp(this.configuration).addCommentQualityScore(userId, postId, commentId, postType, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to create a comment
     * @summary Create A Commnet
     * @param {string} userId the user ID trying to create a comment (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {string} postId The ID of the post to whom to add the comment | type: string
     * @param {CreateCommentAccountTypeEnum} accountType The type of account making the request to create a comment | type: string
     * @param {CreateCommentPostTypeEnum} postType The type of post being reacted to | type: string
     * @param {Comment} comment The actual comment payload | type: json_object
     * @param {string} [communityProfileId] The ID of the community trying to create a comment | type: uint64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public createComment(userId: string, postId: string, accountType: CreateCommentAccountTypeEnum, postType: CreateCommentPostTypeEnum, comment: Comment, communityProfileId?: string, options?: AxiosRequestConfig) {
        return CommentApiFp(this.configuration).createComment(userId, postId, accountType, postType, comment, communityProfileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to delete a comment
     * @summary Delete A Comment
     * @param {string} postId The ID of the post trying to be deleted | type: string
     * @param {string} commentId The ID of the comment trying to be delete | type: string
     * @param {DeleteCommentPostTypeEnum} postType The type of post being reacted to | type: string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public deleteComment(postId: string, commentId: string, postType: DeleteCommentPostTypeEnum, options?: AxiosRequestConfig) {
        return CommentApiFp(this.configuration).deleteComment(postId, commentId, postType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to report a comment
     * @summary Report A Comment
     * @param {string} userId 
     * @param {string} postId 
     * @param {string} commentId 
     * @param {ReportCommentBody} reportCommentBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public reportComment(userId: string, postId: string, commentId: string, reportCommentBody: ReportCommentBody, options?: AxiosRequestConfig) {
        return CommentApiFp(this.configuration).reportComment(userId, postId, commentId, reportCommentBody, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AddCommentQualityScorePostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type AddCommentQualityScorePostTypeEnum = typeof AddCommentQualityScorePostTypeEnum[keyof typeof AddCommentQualityScorePostTypeEnum];
/**
 * @export
 */
export const CreateCommentAccountTypeEnum = {
    Unspecified: 'ACCOUNT_TYPE_UNSPECIFIED',
    User: 'ACCOUNT_TYPE_USER',
    Community: 'ACCOUNT_TYPE_COMMUNITY'
} as const;
export type CreateCommentAccountTypeEnum = typeof CreateCommentAccountTypeEnum[keyof typeof CreateCommentAccountTypeEnum];
/**
 * @export
 */
export const CreateCommentPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type CreateCommentPostTypeEnum = typeof CreateCommentPostTypeEnum[keyof typeof CreateCommentPostTypeEnum];
/**
 * @export
 */
export const DeleteCommentPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type DeleteCommentPostTypeEnum = typeof DeleteCommentPostTypeEnum[keyof typeof DeleteCommentPostTypeEnum];


/**
 * CommentReplyApi - axios parameter creator
 * @export
 */
export const CommentReplyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client to reply to a comment
         * @summary Reply To A Comment
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {CreateCommentReplyBody} createCommentReplyBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCommentReply: async (userId: string, postId: string, commentId: string, createCommentReplyBody: CreateCommentReplyBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createCommentReply', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('createCommentReply', 'postId', postId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('createCommentReply', 'commentId', commentId)
            // verify required parameter 'createCommentReplyBody' is not null or undefined
            assertParamExists('createCommentReply', 'createCommentReplyBody', createCommentReplyBody)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/comment/{commentId}/reply`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCommentReplyBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to delete a comment reply
         * @summary Delete A Comment Reply
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {string} replyId 
         * @param {DeleteCommentReplyPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCommentReply: async (userId: string, postId: string, commentId: string, replyId: string, postType: DeleteCommentReplyPostTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteCommentReply', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('deleteCommentReply', 'postId', postId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('deleteCommentReply', 'commentId', commentId)
            // verify required parameter 'replyId' is not null or undefined
            assertParamExists('deleteCommentReply', 'replyId', replyId)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('deleteCommentReply', 'postType', postType)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/comment/{commentId}/reply/{replyId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"replyId"}}`, encodeURIComponent(String(replyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (postType !== undefined) {
                localVarQueryParameter['postType'] = postType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to edit a comment reply
         * @summary Edit A Comment Reply
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {string} replyId 
         * @param {EditCommentReplyBody} editCommentReplyBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCommentReply: async (userId: string, postId: string, commentId: string, replyId: string, editCommentReplyBody: EditCommentReplyBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('editCommentReply', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('editCommentReply', 'postId', postId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('editCommentReply', 'commentId', commentId)
            // verify required parameter 'replyId' is not null or undefined
            assertParamExists('editCommentReply', 'replyId', replyId)
            // verify required parameter 'editCommentReplyBody' is not null or undefined
            assertParamExists('editCommentReply', 'editCommentReplyBody', editCommentReplyBody)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/comment/{commentId}/reply/{replyId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"replyId"}}`, encodeURIComponent(String(replyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editCommentReplyBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to get comment replies
         * @summary Get Comment Replies
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {GetCommentRepliesPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentReplies: async (userId: string, postId: string, commentId: string, postType: GetCommentRepliesPostTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getCommentReplies', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('getCommentReplies', 'postId', postId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('getCommentReplies', 'commentId', commentId)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('getCommentReplies', 'postType', postType)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/comment/{commentId}/replies`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (postType !== undefined) {
                localVarQueryParameter['postType'] = postType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to report a comment reply
         * @summary Report A Comment Reply
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {string} replyId 
         * @param {ReportCommentReplyBody} reportCommentReplyBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportCommentReply: async (userId: string, postId: string, commentId: string, replyId: string, reportCommentReplyBody: ReportCommentReplyBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('reportCommentReply', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('reportCommentReply', 'postId', postId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('reportCommentReply', 'commentId', commentId)
            // verify required parameter 'replyId' is not null or undefined
            assertParamExists('reportCommentReply', 'replyId', replyId)
            // verify required parameter 'reportCommentReplyBody' is not null or undefined
            assertParamExists('reportCommentReply', 'reportCommentReplyBody', reportCommentReplyBody)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/comment/{commentId}/reply/{replyId}/report`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"replyId"}}`, encodeURIComponent(String(replyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportCommentReplyBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentReplyApi - functional programming interface
 * @export
 */
export const CommentReplyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentReplyApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client to reply to a comment
         * @summary Reply To A Comment
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {CreateCommentReplyBody} createCommentReplyBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCommentReply(userId: string, postId: string, commentId: string, createCommentReplyBody: CreateCommentReplyBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCommentReplyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCommentReply(userId, postId, commentId, createCommentReplyBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CommentReplyApi.createCommentReply']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to delete a comment reply
         * @summary Delete A Comment Reply
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {string} replyId 
         * @param {DeleteCommentReplyPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCommentReply(userId: string, postId: string, commentId: string, replyId: string, postType: DeleteCommentReplyPostTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCommentReplyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCommentReply(userId, postId, commentId, replyId, postType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CommentReplyApi.deleteCommentReply']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to edit a comment reply
         * @summary Edit A Comment Reply
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {string} replyId 
         * @param {EditCommentReplyBody} editCommentReplyBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editCommentReply(userId: string, postId: string, commentId: string, replyId: string, editCommentReplyBody: EditCommentReplyBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditCommentReplyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editCommentReply(userId, postId, commentId, replyId, editCommentReplyBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CommentReplyApi.editCommentReply']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to get comment replies
         * @summary Get Comment Replies
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {GetCommentRepliesPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommentReplies(userId: string, postId: string, commentId: string, postType: GetCommentRepliesPostTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCommentRepliesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommentReplies(userId, postId, commentId, postType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CommentReplyApi.getCommentReplies']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to report a comment reply
         * @summary Report A Comment Reply
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {string} replyId 
         * @param {ReportCommentReplyBody} reportCommentReplyBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportCommentReply(userId: string, postId: string, commentId: string, replyId: string, reportCommentReplyBody: ReportCommentReplyBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportCommentReplyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportCommentReply(userId, postId, commentId, replyId, reportCommentReplyBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CommentReplyApi.reportCommentReply']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CommentReplyApi - factory interface
 * @export
 */
export const CommentReplyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentReplyApiFp(configuration)
    return {
        /**
         * This endpoint enables a client to reply to a comment
         * @summary Reply To A Comment
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {CreateCommentReplyBody} createCommentReplyBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCommentReply(userId: string, postId: string, commentId: string, createCommentReplyBody: CreateCommentReplyBody, options?: any): AxiosPromise<CreateCommentReplyResponse> {
            return localVarFp.createCommentReply(userId, postId, commentId, createCommentReplyBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to delete a comment reply
         * @summary Delete A Comment Reply
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {string} replyId 
         * @param {DeleteCommentReplyPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCommentReply(userId: string, postId: string, commentId: string, replyId: string, postType: DeleteCommentReplyPostTypeEnum, options?: any): AxiosPromise<DeleteCommentReplyResponse> {
            return localVarFp.deleteCommentReply(userId, postId, commentId, replyId, postType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to edit a comment reply
         * @summary Edit A Comment Reply
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {string} replyId 
         * @param {EditCommentReplyBody} editCommentReplyBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCommentReply(userId: string, postId: string, commentId: string, replyId: string, editCommentReplyBody: EditCommentReplyBody, options?: any): AxiosPromise<EditCommentReplyResponse> {
            return localVarFp.editCommentReply(userId, postId, commentId, replyId, editCommentReplyBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to get comment replies
         * @summary Get Comment Replies
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {GetCommentRepliesPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentReplies(userId: string, postId: string, commentId: string, postType: GetCommentRepliesPostTypeEnum, options?: any): AxiosPromise<GetCommentRepliesResponse> {
            return localVarFp.getCommentReplies(userId, postId, commentId, postType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to report a comment reply
         * @summary Report A Comment Reply
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {string} replyId 
         * @param {ReportCommentReplyBody} reportCommentReplyBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportCommentReply(userId: string, postId: string, commentId: string, replyId: string, reportCommentReplyBody: ReportCommentReplyBody, options?: any): AxiosPromise<ReportCommentReplyResponse> {
            return localVarFp.reportCommentReply(userId, postId, commentId, replyId, reportCommentReplyBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentReplyApi - object-oriented interface
 * @export
 * @class CommentReplyApi
 * @extends {BaseAPI}
 */
export class CommentReplyApi extends BaseAPI {
    /**
     * This endpoint enables a client to reply to a comment
     * @summary Reply To A Comment
     * @param {string} userId 
     * @param {string} postId 
     * @param {string} commentId 
     * @param {CreateCommentReplyBody} createCommentReplyBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentReplyApi
     */
    public createCommentReply(userId: string, postId: string, commentId: string, createCommentReplyBody: CreateCommentReplyBody, options?: AxiosRequestConfig) {
        return CommentReplyApiFp(this.configuration).createCommentReply(userId, postId, commentId, createCommentReplyBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to delete a comment reply
     * @summary Delete A Comment Reply
     * @param {string} userId 
     * @param {string} postId 
     * @param {string} commentId 
     * @param {string} replyId 
     * @param {DeleteCommentReplyPostTypeEnum} postType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentReplyApi
     */
    public deleteCommentReply(userId: string, postId: string, commentId: string, replyId: string, postType: DeleteCommentReplyPostTypeEnum, options?: AxiosRequestConfig) {
        return CommentReplyApiFp(this.configuration).deleteCommentReply(userId, postId, commentId, replyId, postType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to edit a comment reply
     * @summary Edit A Comment Reply
     * @param {string} userId 
     * @param {string} postId 
     * @param {string} commentId 
     * @param {string} replyId 
     * @param {EditCommentReplyBody} editCommentReplyBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentReplyApi
     */
    public editCommentReply(userId: string, postId: string, commentId: string, replyId: string, editCommentReplyBody: EditCommentReplyBody, options?: AxiosRequestConfig) {
        return CommentReplyApiFp(this.configuration).editCommentReply(userId, postId, commentId, replyId, editCommentReplyBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to get comment replies
     * @summary Get Comment Replies
     * @param {string} userId 
     * @param {string} postId 
     * @param {string} commentId 
     * @param {GetCommentRepliesPostTypeEnum} postType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentReplyApi
     */
    public getCommentReplies(userId: string, postId: string, commentId: string, postType: GetCommentRepliesPostTypeEnum, options?: AxiosRequestConfig) {
        return CommentReplyApiFp(this.configuration).getCommentReplies(userId, postId, commentId, postType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to report a comment reply
     * @summary Report A Comment Reply
     * @param {string} userId 
     * @param {string} postId 
     * @param {string} commentId 
     * @param {string} replyId 
     * @param {ReportCommentReplyBody} reportCommentReplyBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentReplyApi
     */
    public reportCommentReply(userId: string, postId: string, commentId: string, replyId: string, reportCommentReplyBody: ReportCommentReplyBody, options?: AxiosRequestConfig) {
        return CommentReplyApiFp(this.configuration).reportCommentReply(userId, postId, commentId, replyId, reportCommentReplyBody, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeleteCommentReplyPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type DeleteCommentReplyPostTypeEnum = typeof DeleteCommentReplyPostTypeEnum[keyof typeof DeleteCommentReplyPostTypeEnum];
/**
 * @export
 */
export const GetCommentRepliesPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type GetCommentRepliesPostTypeEnum = typeof GetCommentRepliesPostTypeEnum[keyof typeof GetCommentRepliesPostTypeEnum];


/**
 * CommunityProfileApi - axios parameter creator
 * @export
 */
export const CommunityProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client to create a community profile
         * @summary Create a community Profile
         * @param {string} userId the user ID trying to create this community profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {CreateCommunityProfileBody} createCommunityProfileBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCommunityProfile: async (userId: string, createCommunityProfileBody: CreateCommunityProfileBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createCommunityProfile', 'userId', userId)
            // verify required parameter 'createCommunityProfileBody' is not null or undefined
            assertParamExists('createCommunityProfile', 'createCommunityProfileBody', createCommunityProfileBody)
            const localVarPath = `/api/v1/community-profiles/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCommunityProfileBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to delete a community profile
         * @summary Delete Community Profile
         * @param {string} userId the user ID trying to delete this community profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} communityProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCommunityProfile: async (userId: string, communityProfileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteCommunityProfile', 'userId', userId)
            // verify required parameter 'communityProfileId' is not null or undefined
            assertParamExists('deleteCommunityProfile', 'communityProfileId', communityProfileId)
            const localVarPath = `/api/v1/users/{userId}/community-profiles/{communityProfileId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"communityProfileId"}}`, encodeURIComponent(String(communityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to update a community profile
         * @summary Edit a community Profile
         * @param {string} userId the user ID trying to update this community profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} communityProfileId The community profile ID of the community being updated | type: uint64
         * @param {CommunityProfile} communityProfile The community profile being updated | type: json_object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCommunityProfile: async (userId: string, communityProfileId: string, communityProfile: CommunityProfile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('editCommunityProfile', 'userId', userId)
            // verify required parameter 'communityProfileId' is not null or undefined
            assertParamExists('editCommunityProfile', 'communityProfileId', communityProfileId)
            // verify required parameter 'communityProfile' is not null or undefined
            assertParamExists('editCommunityProfile', 'communityProfile', communityProfile)
            const localVarPath = `/api/v1/users/{userId}/community-profiles/{communityProfileId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"communityProfileId"}}`, encodeURIComponent(String(communityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(communityProfile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to get all the communities a user follows
         * @summary Gets all the communities a user follows
         * @param {string} userId the user ID who\&#39;s communities follow set we want to obtain (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} limit the max number of communities to return | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunitiesUserFollows: async (userId: string, limit: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getCommunitiesUserFollows', 'userId', userId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getCommunitiesUserFollows', 'limit', limit)
            const localVarPath = `/api/v1/users/{userId}/communities-followed`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to get a community profile
         * @summary Get a community Profile
         * @param {string} communityId The communityID associated with the community being requested  | type: uint64
         * @param {string} requestorProfileId The RequestorProfileID is an optional parameter used to check if the profileID (requestor) making a request for the record actually follows the record
         * @param {GetCommunityProfileRequestorProfileTypeEnum} requestorProfileType The RequestorProfileType is an optional parameter which tells us what type of profile is the requestor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunityProfile: async (communityId: string, requestorProfileId: string, requestorProfileType: GetCommunityProfileRequestorProfileTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'communityId' is not null or undefined
            assertParamExists('getCommunityProfile', 'communityId', communityId)
            // verify required parameter 'requestorProfileId' is not null or undefined
            assertParamExists('getCommunityProfile', 'requestorProfileId', requestorProfileId)
            // verify required parameter 'requestorProfileType' is not null or undefined
            assertParamExists('getCommunityProfile', 'requestorProfileType', requestorProfileType)
            const localVarPath = `/api/v1/social/community-profiles/{communityId}/requestor/{requestorProfileId}/profile-type/{requestorProfileType}`
                .replace(`{${"communityId"}}`, encodeURIComponent(String(communityId)))
                .replace(`{${"requestorProfileId"}}`, encodeURIComponent(String(requestorProfileId)))
                .replace(`{${"requestorProfileType"}}`, encodeURIComponent(String(requestorProfileType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to get community profiles
         * @summary Get Community Profiles
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunityProfiles: async (pageSize: number, pageNumber: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getCommunityProfiles', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('getCommunityProfiles', 'pageNumber', pageNumber)
            const localVarPath = `/api/v1/community-profiles/page-size/{pageSize}/page-number/{pageNumber}`
                .replace(`{${"pageSize"}}`, encodeURIComponent(String(pageSize)))
                .replace(`{${"pageNumber"}}`, encodeURIComponent(String(pageNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommunityProfileApi - functional programming interface
 * @export
 */
export const CommunityProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommunityProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client to create a community profile
         * @summary Create a community Profile
         * @param {string} userId the user ID trying to create this community profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {CreateCommunityProfileBody} createCommunityProfileBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCommunityProfile(userId: string, createCommunityProfileBody: CreateCommunityProfileBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCommunityProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCommunityProfile(userId, createCommunityProfileBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CommunityProfileApi.createCommunityProfile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to delete a community profile
         * @summary Delete Community Profile
         * @param {string} userId the user ID trying to delete this community profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} communityProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCommunityProfile(userId: string, communityProfileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCommunityProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCommunityProfile(userId, communityProfileId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CommunityProfileApi.deleteCommunityProfile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to update a community profile
         * @summary Edit a community Profile
         * @param {string} userId the user ID trying to update this community profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} communityProfileId The community profile ID of the community being updated | type: uint64
         * @param {CommunityProfile} communityProfile The community profile being updated | type: json_object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editCommunityProfile(userId: string, communityProfileId: string, communityProfile: CommunityProfile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditCommunityProfileRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editCommunityProfile(userId, communityProfileId, communityProfile, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CommunityProfileApi.editCommunityProfile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to get all the communities a user follows
         * @summary Gets all the communities a user follows
         * @param {string} userId the user ID who\&#39;s communities follow set we want to obtain (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} limit the max number of communities to return | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommunitiesUserFollows(userId: string, limit: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCommunitiesUserFollowsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommunitiesUserFollows(userId, limit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CommunityProfileApi.getCommunitiesUserFollows']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to get a community profile
         * @summary Get a community Profile
         * @param {string} communityId The communityID associated with the community being requested  | type: uint64
         * @param {string} requestorProfileId The RequestorProfileID is an optional parameter used to check if the profileID (requestor) making a request for the record actually follows the record
         * @param {GetCommunityProfileRequestorProfileTypeEnum} requestorProfileType The RequestorProfileType is an optional parameter which tells us what type of profile is the requestor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommunityProfile(communityId: string, requestorProfileId: string, requestorProfileType: GetCommunityProfileRequestorProfileTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCommunityProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommunityProfile(communityId, requestorProfileId, requestorProfileType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CommunityProfileApi.getCommunityProfile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to get community profiles
         * @summary Get Community Profiles
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommunityProfiles(pageSize: number, pageNumber: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCommunityProfilesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommunityProfiles(pageSize, pageNumber, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CommunityProfileApi.getCommunityProfiles']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CommunityProfileApi - factory interface
 * @export
 */
export const CommunityProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommunityProfileApiFp(configuration)
    return {
        /**
         * This endpoint enables a client to create a community profile
         * @summary Create a community Profile
         * @param {string} userId the user ID trying to create this community profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {CreateCommunityProfileBody} createCommunityProfileBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCommunityProfile(userId: string, createCommunityProfileBody: CreateCommunityProfileBody, options?: any): AxiosPromise<CreateCommunityProfileResponse> {
            return localVarFp.createCommunityProfile(userId, createCommunityProfileBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to delete a community profile
         * @summary Delete Community Profile
         * @param {string} userId the user ID trying to delete this community profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} communityProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCommunityProfile(userId: string, communityProfileId: string, options?: any): AxiosPromise<DeleteCommunityProfileResponse> {
            return localVarFp.deleteCommunityProfile(userId, communityProfileId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to update a community profile
         * @summary Edit a community Profile
         * @param {string} userId the user ID trying to update this community profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} communityProfileId The community profile ID of the community being updated | type: uint64
         * @param {CommunityProfile} communityProfile The community profile being updated | type: json_object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCommunityProfile(userId: string, communityProfileId: string, communityProfile: CommunityProfile, options?: any): AxiosPromise<EditCommunityProfileRequest> {
            return localVarFp.editCommunityProfile(userId, communityProfileId, communityProfile, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to get all the communities a user follows
         * @summary Gets all the communities a user follows
         * @param {string} userId the user ID who\&#39;s communities follow set we want to obtain (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} limit the max number of communities to return | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunitiesUserFollows(userId: string, limit: string, options?: any): AxiosPromise<GetCommunitiesUserFollowsResponse> {
            return localVarFp.getCommunitiesUserFollows(userId, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to get a community profile
         * @summary Get a community Profile
         * @param {string} communityId The communityID associated with the community being requested  | type: uint64
         * @param {string} requestorProfileId The RequestorProfileID is an optional parameter used to check if the profileID (requestor) making a request for the record actually follows the record
         * @param {GetCommunityProfileRequestorProfileTypeEnum} requestorProfileType The RequestorProfileType is an optional parameter which tells us what type of profile is the requestor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunityProfile(communityId: string, requestorProfileId: string, requestorProfileType: GetCommunityProfileRequestorProfileTypeEnum, options?: any): AxiosPromise<GetCommunityProfileResponse> {
            return localVarFp.getCommunityProfile(communityId, requestorProfileId, requestorProfileType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to get community profiles
         * @summary Get Community Profiles
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunityProfiles(pageSize: number, pageNumber: number, options?: any): AxiosPromise<GetCommunityProfilesResponse> {
            return localVarFp.getCommunityProfiles(pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommunityProfileApi - object-oriented interface
 * @export
 * @class CommunityProfileApi
 * @extends {BaseAPI}
 */
export class CommunityProfileApi extends BaseAPI {
    /**
     * This endpoint enables a client to create a community profile
     * @summary Create a community Profile
     * @param {string} userId the user ID trying to create this community profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {CreateCommunityProfileBody} createCommunityProfileBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityProfileApi
     */
    public createCommunityProfile(userId: string, createCommunityProfileBody: CreateCommunityProfileBody, options?: AxiosRequestConfig) {
        return CommunityProfileApiFp(this.configuration).createCommunityProfile(userId, createCommunityProfileBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to delete a community profile
     * @summary Delete Community Profile
     * @param {string} userId the user ID trying to delete this community profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {string} communityProfileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityProfileApi
     */
    public deleteCommunityProfile(userId: string, communityProfileId: string, options?: AxiosRequestConfig) {
        return CommunityProfileApiFp(this.configuration).deleteCommunityProfile(userId, communityProfileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to update a community profile
     * @summary Edit a community Profile
     * @param {string} userId the user ID trying to update this community profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {string} communityProfileId The community profile ID of the community being updated | type: uint64
     * @param {CommunityProfile} communityProfile The community profile being updated | type: json_object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityProfileApi
     */
    public editCommunityProfile(userId: string, communityProfileId: string, communityProfile: CommunityProfile, options?: AxiosRequestConfig) {
        return CommunityProfileApiFp(this.configuration).editCommunityProfile(userId, communityProfileId, communityProfile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to get all the communities a user follows
     * @summary Gets all the communities a user follows
     * @param {string} userId the user ID who\&#39;s communities follow set we want to obtain (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {string} limit the max number of communities to return | type: uint64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityProfileApi
     */
    public getCommunitiesUserFollows(userId: string, limit: string, options?: AxiosRequestConfig) {
        return CommunityProfileApiFp(this.configuration).getCommunitiesUserFollows(userId, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to get a community profile
     * @summary Get a community Profile
     * @param {string} communityId The communityID associated with the community being requested  | type: uint64
     * @param {string} requestorProfileId The RequestorProfileID is an optional parameter used to check if the profileID (requestor) making a request for the record actually follows the record
     * @param {GetCommunityProfileRequestorProfileTypeEnum} requestorProfileType The RequestorProfileType is an optional parameter which tells us what type of profile is the requestor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityProfileApi
     */
    public getCommunityProfile(communityId: string, requestorProfileId: string, requestorProfileType: GetCommunityProfileRequestorProfileTypeEnum, options?: AxiosRequestConfig) {
        return CommunityProfileApiFp(this.configuration).getCommunityProfile(communityId, requestorProfileId, requestorProfileType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to get community profiles
     * @summary Get Community Profiles
     * @param {number} pageSize 
     * @param {number} pageNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityProfileApi
     */
    public getCommunityProfiles(pageSize: number, pageNumber: number, options?: AxiosRequestConfig) {
        return CommunityProfileApiFp(this.configuration).getCommunityProfiles(pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetCommunityProfileRequestorProfileTypeEnum = {
    Unspecified: 'ACCOUNT_TYPE_UNSPECIFIED',
    User: 'ACCOUNT_TYPE_USER',
    Community: 'ACCOUNT_TYPE_COMMUNITY'
} as const;
export type GetCommunityProfileRequestorProfileTypeEnum = typeof GetCommunityProfileRequestorProfileTypeEnum[keyof typeof GetCommunityProfileRequestorProfileTypeEnum];


/**
 * FeedApi - axios parameter creator
 * @export
 */
export const FeedApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client query a community feed
         * @summary Gets A Community Feed
         * @param {string} communityProfileId The ID of the community we are trying to obtain the feed for | type: uint64
         * @param {GetCommunityFeedFeedTypeEnum} feedType The type of feed aiming to be obtained | type: string   - FEED_TYPE_PERSONAL: UserFeed is a profile\&#39;s personal feed  - FEED_TYPE_NEWS: NewsFeed is a profile\&#39;s timeline  - FEED_TYPE_NOTIFICATION: NotificationFeed encompasses a profile\&#39;s notification feed
         * @param {GetCommunityFeedAccountTypeEnum} accountType The type of account making the request to obtain the feed | type: string
         * @param {string} [nextPageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunityFeed: async (communityProfileId: string, feedType: GetCommunityFeedFeedTypeEnum, accountType: GetCommunityFeedAccountTypeEnum, nextPageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'communityProfileId' is not null or undefined
            assertParamExists('getCommunityFeed', 'communityProfileId', communityProfileId)
            // verify required parameter 'feedType' is not null or undefined
            assertParamExists('getCommunityFeed', 'feedType', feedType)
            // verify required parameter 'accountType' is not null or undefined
            assertParamExists('getCommunityFeed', 'accountType', accountType)
            const localVarPath = `/api/v1/community-profiles/{communityProfileId}/timeline`
                .replace(`{${"communityProfileId"}}`, encodeURIComponent(String(communityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (feedType !== undefined) {
                localVarQueryParameter['feedType'] = feedType;
            }

            if (accountType !== undefined) {
                localVarQueryParameter['accountType'] = accountType;
            }

            if (nextPageToken !== undefined) {
                localVarQueryParameter['nextPageToken'] = nextPageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client query a user feed
         * @summary Gets A Userfeed
         * @param {string} userId the user ID trying to obtain a given feed (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {GetUserFeedFeedTypeEnum} feedType The type of feed aiming to be obtained | type: string   - FEED_TYPE_PERSONAL: UserFeed is a profile\&#39;s personal feed  - FEED_TYPE_NEWS: NewsFeed is a profile\&#39;s timeline  - FEED_TYPE_NOTIFICATION: NotificationFeed encompasses a profile\&#39;s notification feed
         * @param {GetUserFeedAccountTypeEnum} accountType The type of account making the request to obtain the feed | type: string
         * @param {string} [nextPageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFeed: async (userId: string, feedType: GetUserFeedFeedTypeEnum, accountType: GetUserFeedAccountTypeEnum, nextPageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserFeed', 'userId', userId)
            // verify required parameter 'feedType' is not null or undefined
            assertParamExists('getUserFeed', 'feedType', feedType)
            // verify required parameter 'accountType' is not null or undefined
            assertParamExists('getUserFeed', 'accountType', accountType)
            const localVarPath = `/api/v1/users/{userId}/timeline`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (feedType !== undefined) {
                localVarQueryParameter['feedType'] = feedType;
            }

            if (accountType !== undefined) {
                localVarQueryParameter['accountType'] = accountType;
            }

            if (nextPageToken !== undefined) {
                localVarQueryParameter['nextPageToken'] = nextPageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to share a post
         * @summary Share a post
         * @param {string} userId 
         * @param {string} parentPostId 
         * @param {SharePostParentPostTypeEnum} parentPostType 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharePost: async (userId: string, parentPostId: string, parentPostType: SharePostParentPostTypeEnum, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('sharePost', 'userId', userId)
            // verify required parameter 'parentPostId' is not null or undefined
            assertParamExists('sharePost', 'parentPostId', parentPostId)
            // verify required parameter 'parentPostType' is not null or undefined
            assertParamExists('sharePost', 'parentPostType', parentPostType)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('sharePost', 'body', body)
            const localVarPath = `/api/v1/users/{userId}/post/share/{parentPostId}/type/{parentPostType}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"parentPostId"}}`, encodeURIComponent(String(parentPostId)))
                .replace(`{${"parentPostType"}}`, encodeURIComponent(String(parentPostType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedApi - functional programming interface
 * @export
 */
export const FeedApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client query a community feed
         * @summary Gets A Community Feed
         * @param {string} communityProfileId The ID of the community we are trying to obtain the feed for | type: uint64
         * @param {GetCommunityFeedFeedTypeEnum} feedType The type of feed aiming to be obtained | type: string   - FEED_TYPE_PERSONAL: UserFeed is a profile\&#39;s personal feed  - FEED_TYPE_NEWS: NewsFeed is a profile\&#39;s timeline  - FEED_TYPE_NOTIFICATION: NotificationFeed encompasses a profile\&#39;s notification feed
         * @param {GetCommunityFeedAccountTypeEnum} accountType The type of account making the request to obtain the feed | type: string
         * @param {string} [nextPageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommunityFeed(communityProfileId: string, feedType: GetCommunityFeedFeedTypeEnum, accountType: GetCommunityFeedAccountTypeEnum, nextPageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCommunityFeedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommunityFeed(communityProfileId, feedType, accountType, nextPageToken, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FeedApi.getCommunityFeed']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client query a user feed
         * @summary Gets A Userfeed
         * @param {string} userId the user ID trying to obtain a given feed (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {GetUserFeedFeedTypeEnum} feedType The type of feed aiming to be obtained | type: string   - FEED_TYPE_PERSONAL: UserFeed is a profile\&#39;s personal feed  - FEED_TYPE_NEWS: NewsFeed is a profile\&#39;s timeline  - FEED_TYPE_NOTIFICATION: NotificationFeed encompasses a profile\&#39;s notification feed
         * @param {GetUserFeedAccountTypeEnum} accountType The type of account making the request to obtain the feed | type: string
         * @param {string} [nextPageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFeed(userId: string, feedType: GetUserFeedFeedTypeEnum, accountType: GetUserFeedAccountTypeEnum, nextPageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserFeedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFeed(userId, feedType, accountType, nextPageToken, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FeedApi.getUserFeed']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to share a post
         * @summary Share a post
         * @param {string} userId 
         * @param {string} parentPostId 
         * @param {SharePostParentPostTypeEnum} parentPostType 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sharePost(userId: string, parentPostId: string, parentPostType: SharePostParentPostTypeEnum, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharePostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sharePost(userId, parentPostId, parentPostType, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FeedApi.sharePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FeedApi - factory interface
 * @export
 */
export const FeedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedApiFp(configuration)
    return {
        /**
         * This endpoint enables a client query a community feed
         * @summary Gets A Community Feed
         * @param {string} communityProfileId The ID of the community we are trying to obtain the feed for | type: uint64
         * @param {GetCommunityFeedFeedTypeEnum} feedType The type of feed aiming to be obtained | type: string   - FEED_TYPE_PERSONAL: UserFeed is a profile\&#39;s personal feed  - FEED_TYPE_NEWS: NewsFeed is a profile\&#39;s timeline  - FEED_TYPE_NOTIFICATION: NotificationFeed encompasses a profile\&#39;s notification feed
         * @param {GetCommunityFeedAccountTypeEnum} accountType The type of account making the request to obtain the feed | type: string
         * @param {string} [nextPageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunityFeed(communityProfileId: string, feedType: GetCommunityFeedFeedTypeEnum, accountType: GetCommunityFeedAccountTypeEnum, nextPageToken?: string, options?: any): AxiosPromise<GetCommunityFeedResponse> {
            return localVarFp.getCommunityFeed(communityProfileId, feedType, accountType, nextPageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client query a user feed
         * @summary Gets A Userfeed
         * @param {string} userId the user ID trying to obtain a given feed (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {GetUserFeedFeedTypeEnum} feedType The type of feed aiming to be obtained | type: string   - FEED_TYPE_PERSONAL: UserFeed is a profile\&#39;s personal feed  - FEED_TYPE_NEWS: NewsFeed is a profile\&#39;s timeline  - FEED_TYPE_NOTIFICATION: NotificationFeed encompasses a profile\&#39;s notification feed
         * @param {GetUserFeedAccountTypeEnum} accountType The type of account making the request to obtain the feed | type: string
         * @param {string} [nextPageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFeed(userId: string, feedType: GetUserFeedFeedTypeEnum, accountType: GetUserFeedAccountTypeEnum, nextPageToken?: string, options?: any): AxiosPromise<GetUserFeedResponse> {
            return localVarFp.getUserFeed(userId, feedType, accountType, nextPageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to share a post
         * @summary Share a post
         * @param {string} userId 
         * @param {string} parentPostId 
         * @param {SharePostParentPostTypeEnum} parentPostType 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharePost(userId: string, parentPostId: string, parentPostType: SharePostParentPostTypeEnum, body: string, options?: any): AxiosPromise<SharePostResponse> {
            return localVarFp.sharePost(userId, parentPostId, parentPostType, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeedApi - object-oriented interface
 * @export
 * @class FeedApi
 * @extends {BaseAPI}
 */
export class FeedApi extends BaseAPI {
    /**
     * This endpoint enables a client query a community feed
     * @summary Gets A Community Feed
     * @param {string} communityProfileId The ID of the community we are trying to obtain the feed for | type: uint64
     * @param {GetCommunityFeedFeedTypeEnum} feedType The type of feed aiming to be obtained | type: string   - FEED_TYPE_PERSONAL: UserFeed is a profile\&#39;s personal feed  - FEED_TYPE_NEWS: NewsFeed is a profile\&#39;s timeline  - FEED_TYPE_NOTIFICATION: NotificationFeed encompasses a profile\&#39;s notification feed
     * @param {GetCommunityFeedAccountTypeEnum} accountType The type of account making the request to obtain the feed | type: string
     * @param {string} [nextPageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    public getCommunityFeed(communityProfileId: string, feedType: GetCommunityFeedFeedTypeEnum, accountType: GetCommunityFeedAccountTypeEnum, nextPageToken?: string, options?: AxiosRequestConfig) {
        return FeedApiFp(this.configuration).getCommunityFeed(communityProfileId, feedType, accountType, nextPageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client query a user feed
     * @summary Gets A Userfeed
     * @param {string} userId the user ID trying to obtain a given feed (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {GetUserFeedFeedTypeEnum} feedType The type of feed aiming to be obtained | type: string   - FEED_TYPE_PERSONAL: UserFeed is a profile\&#39;s personal feed  - FEED_TYPE_NEWS: NewsFeed is a profile\&#39;s timeline  - FEED_TYPE_NOTIFICATION: NotificationFeed encompasses a profile\&#39;s notification feed
     * @param {GetUserFeedAccountTypeEnum} accountType The type of account making the request to obtain the feed | type: string
     * @param {string} [nextPageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    public getUserFeed(userId: string, feedType: GetUserFeedFeedTypeEnum, accountType: GetUserFeedAccountTypeEnum, nextPageToken?: string, options?: AxiosRequestConfig) {
        return FeedApiFp(this.configuration).getUserFeed(userId, feedType, accountType, nextPageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to share a post
     * @summary Share a post
     * @param {string} userId 
     * @param {string} parentPostId 
     * @param {SharePostParentPostTypeEnum} parentPostType 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    public sharePost(userId: string, parentPostId: string, parentPostType: SharePostParentPostTypeEnum, body: string, options?: AxiosRequestConfig) {
        return FeedApiFp(this.configuration).sharePost(userId, parentPostId, parentPostType, body, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetCommunityFeedFeedTypeEnum = {
    Unspecified: 'FEED_TYPE_UNSPECIFIED',
    Personal: 'FEED_TYPE_PERSONAL',
    News: 'FEED_TYPE_NEWS',
    Notification: 'FEED_TYPE_NOTIFICATION'
} as const;
export type GetCommunityFeedFeedTypeEnum = typeof GetCommunityFeedFeedTypeEnum[keyof typeof GetCommunityFeedFeedTypeEnum];
/**
 * @export
 */
export const GetCommunityFeedAccountTypeEnum = {
    Unspecified: 'ACCOUNT_TYPE_UNSPECIFIED',
    User: 'ACCOUNT_TYPE_USER',
    Community: 'ACCOUNT_TYPE_COMMUNITY'
} as const;
export type GetCommunityFeedAccountTypeEnum = typeof GetCommunityFeedAccountTypeEnum[keyof typeof GetCommunityFeedAccountTypeEnum];
/**
 * @export
 */
export const GetUserFeedFeedTypeEnum = {
    Unspecified: 'FEED_TYPE_UNSPECIFIED',
    Personal: 'FEED_TYPE_PERSONAL',
    News: 'FEED_TYPE_NEWS',
    Notification: 'FEED_TYPE_NOTIFICATION'
} as const;
export type GetUserFeedFeedTypeEnum = typeof GetUserFeedFeedTypeEnum[keyof typeof GetUserFeedFeedTypeEnum];
/**
 * @export
 */
export const GetUserFeedAccountTypeEnum = {
    Unspecified: 'ACCOUNT_TYPE_UNSPECIFIED',
    User: 'ACCOUNT_TYPE_USER',
    Community: 'ACCOUNT_TYPE_COMMUNITY'
} as const;
export type GetUserFeedAccountTypeEnum = typeof GetUserFeedAccountTypeEnum[keyof typeof GetUserFeedAccountTypeEnum];
/**
 * @export
 */
export const SharePostParentPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type SharePostParentPostTypeEnum = typeof SharePostParentPostTypeEnum[keyof typeof SharePostParentPostTypeEnum];


/**
 * FollowApi - axios parameter creator
 * @export
 */
export const FollowApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client to get all the accounts a given user follows
         * @summary Get Communities and users you are following
         * @param {string} userId 
         * @param {string} profileId 
         * @param {GetAccountsFollowingAccountTypeEnum} accountType the account type of the user whoses followers are being requested
         * @param {string} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsFollowing: async (userId: string, profileId: string, accountType: GetAccountsFollowingAccountTypeEnum, limit: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAccountsFollowing', 'userId', userId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('getAccountsFollowing', 'profileId', profileId)
            // verify required parameter 'accountType' is not null or undefined
            assertParamExists('getAccountsFollowing', 'accountType', accountType)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getAccountsFollowing', 'limit', limit)
            const localVarPath = `/api/v1/users/{userId}/profile/{profileId}/account-type/{accountType}/following`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)))
                .replace(`{${"accountType"}}`, encodeURIComponent(String(accountType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to get all the followers following a given user
         * @summary Get Users Following you
         * @param {string} userId 
         * @param {string} profileId 
         * @param {string} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowers: async (userId: string, profileId: string, limit: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getFollowers', 'userId', userId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('getFollowers', 'profileId', profileId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getFollowers', 'limit', limit)
            const localVarPath = `/api/v1/users/{userId}/profile/{profileId}/followers`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to get all the pending follow requests
         * @summary Get Pending Follow Requests
         * @param {string} userId the user ID who\&#39;s pending request we want to obtain (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingFollows: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getPendingFollows', 'userId', userId)
            const localVarPath = `/api/v1/users/{userId}/follow/pending-requests`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FollowApi - functional programming interface
 * @export
 */
export const FollowApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FollowApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client to get all the accounts a given user follows
         * @summary Get Communities and users you are following
         * @param {string} userId 
         * @param {string} profileId 
         * @param {GetAccountsFollowingAccountTypeEnum} accountType the account type of the user whoses followers are being requested
         * @param {string} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsFollowing(userId: string, profileId: string, accountType: GetAccountsFollowingAccountTypeEnum, limit: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountsFollowingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsFollowing(userId, profileId, accountType, limit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FollowApi.getAccountsFollowing']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to get all the followers following a given user
         * @summary Get Users Following you
         * @param {string} userId 
         * @param {string} profileId 
         * @param {string} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowers(userId: string, profileId: string, limit: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFollowersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowers(userId, profileId, limit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FollowApi.getFollowers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to get all the pending follow requests
         * @summary Get Pending Follow Requests
         * @param {string} userId the user ID who\&#39;s pending request we want to obtain (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingFollows(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPendingFollowsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingFollows(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FollowApi.getPendingFollows']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FollowApi - factory interface
 * @export
 */
export const FollowApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FollowApiFp(configuration)
    return {
        /**
         * This endpoint enables a client to get all the accounts a given user follows
         * @summary Get Communities and users you are following
         * @param {string} userId 
         * @param {string} profileId 
         * @param {GetAccountsFollowingAccountTypeEnum} accountType the account type of the user whoses followers are being requested
         * @param {string} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsFollowing(userId: string, profileId: string, accountType: GetAccountsFollowingAccountTypeEnum, limit: string, options?: any): AxiosPromise<GetAccountsFollowingResponse> {
            return localVarFp.getAccountsFollowing(userId, profileId, accountType, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to get all the followers following a given user
         * @summary Get Users Following you
         * @param {string} userId 
         * @param {string} profileId 
         * @param {string} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowers(userId: string, profileId: string, limit: string, options?: any): AxiosPromise<GetFollowersResponse> {
            return localVarFp.getFollowers(userId, profileId, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to get all the pending follow requests
         * @summary Get Pending Follow Requests
         * @param {string} userId the user ID who\&#39;s pending request we want to obtain (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingFollows(userId: string, options?: any): AxiosPromise<GetPendingFollowsResponse> {
            return localVarFp.getPendingFollows(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FollowApi - object-oriented interface
 * @export
 * @class FollowApi
 * @extends {BaseAPI}
 */
export class FollowApi extends BaseAPI {
    /**
     * This endpoint enables a client to get all the accounts a given user follows
     * @summary Get Communities and users you are following
     * @param {string} userId 
     * @param {string} profileId 
     * @param {GetAccountsFollowingAccountTypeEnum} accountType the account type of the user whoses followers are being requested
     * @param {string} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowApi
     */
    public getAccountsFollowing(userId: string, profileId: string, accountType: GetAccountsFollowingAccountTypeEnum, limit: string, options?: AxiosRequestConfig) {
        return FollowApiFp(this.configuration).getAccountsFollowing(userId, profileId, accountType, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to get all the followers following a given user
     * @summary Get Users Following you
     * @param {string} userId 
     * @param {string} profileId 
     * @param {string} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowApi
     */
    public getFollowers(userId: string, profileId: string, limit: string, options?: AxiosRequestConfig) {
        return FollowApiFp(this.configuration).getFollowers(userId, profileId, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to get all the pending follow requests
     * @summary Get Pending Follow Requests
     * @param {string} userId the user ID who\&#39;s pending request we want to obtain (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowApi
     */
    public getPendingFollows(userId: string, options?: AxiosRequestConfig) {
        return FollowApiFp(this.configuration).getPendingFollows(userId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAccountsFollowingAccountTypeEnum = {
    Unspecified: 'ACCOUNT_TYPE_UNSPECIFIED',
    User: 'ACCOUNT_TYPE_USER',
    Community: 'ACCOUNT_TYPE_COMMUNITY'
} as const;
export type GetAccountsFollowingAccountTypeEnum = typeof GetAccountsFollowingAccountTypeEnum[keyof typeof GetAccountsFollowingAccountTypeEnum];


/**
 * FollowCommunityProfileApi - axios parameter creator
 * @export
 */
export const FollowCommunityProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client to follow a community profile
         * @summary Follows A Community Profile
         * @param {string} sourceUserId the user ID trying to follow another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} targetCommunityProfileId the targetCommunityProfileID ID being followed by another user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followCommunityProfile: async (sourceUserId: string, targetCommunityProfileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUserId' is not null or undefined
            assertParamExists('followCommunityProfile', 'sourceUserId', sourceUserId)
            // verify required parameter 'targetCommunityProfileId' is not null or undefined
            assertParamExists('followCommunityProfile', 'targetCommunityProfileId', targetCommunityProfileId)
            const localVarPath = `/api/v1/users/source/{sourceUserId}/follow/community-profiles/{targetCommunityProfileId}`
                .replace(`{${"sourceUserId"}}`, encodeURIComponent(String(sourceUserId)))
                .replace(`{${"targetCommunityProfileId"}}`, encodeURIComponent(String(targetCommunityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FollowCommunityProfileApi - functional programming interface
 * @export
 */
export const FollowCommunityProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FollowCommunityProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client to follow a community profile
         * @summary Follows A Community Profile
         * @param {string} sourceUserId the user ID trying to follow another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} targetCommunityProfileId the targetCommunityProfileID ID being followed by another user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followCommunityProfile(sourceUserId: string, targetCommunityProfileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FollowCommunityProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followCommunityProfile(sourceUserId, targetCommunityProfileId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FollowCommunityProfileApi.followCommunityProfile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FollowCommunityProfileApi - factory interface
 * @export
 */
export const FollowCommunityProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FollowCommunityProfileApiFp(configuration)
    return {
        /**
         * This endpoint enables a client to follow a community profile
         * @summary Follows A Community Profile
         * @param {string} sourceUserId the user ID trying to follow another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} targetCommunityProfileId the targetCommunityProfileID ID being followed by another user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followCommunityProfile(sourceUserId: string, targetCommunityProfileId: string, options?: any): AxiosPromise<FollowCommunityProfileResponse> {
            return localVarFp.followCommunityProfile(sourceUserId, targetCommunityProfileId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FollowCommunityProfileApi - object-oriented interface
 * @export
 * @class FollowCommunityProfileApi
 * @extends {BaseAPI}
 */
export class FollowCommunityProfileApi extends BaseAPI {
    /**
     * This endpoint enables a client to follow a community profile
     * @summary Follows A Community Profile
     * @param {string} sourceUserId the user ID trying to follow another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {string} targetCommunityProfileId the targetCommunityProfileID ID being followed by another user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowCommunityProfileApi
     */
    public followCommunityProfile(sourceUserId: string, targetCommunityProfileId: string, options?: AxiosRequestConfig) {
        return FollowCommunityProfileApiFp(this.configuration).followCommunityProfile(sourceUserId, targetCommunityProfileId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FollowProfileApi - axios parameter creator
 * @export
 */
export const FollowProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client to accept a follow request from a source a user profile
         * @summary Accepts a user\'s follow request
         * @param {string} followRecordId The id of the follow record | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFollowProfile: async (followRecordId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'followRecordId' is not null or undefined
            assertParamExists('acceptFollowProfile', 'followRecordId', followRecordId)
            const localVarPath = `/api/v1/follow-requests/{followRecordId}/accept`
                .replace(`{${"followRecordId"}}`, encodeURIComponent(String(followRecordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to follow a user profile
         * @summary follow a user profile
         * @param {string} sourceUserId the user ID trying to follow another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} targetUserId the user ID being followed by another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followProfile: async (sourceUserId: string, targetUserId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUserId' is not null or undefined
            assertParamExists('followProfile', 'sourceUserId', sourceUserId)
            // verify required parameter 'targetUserId' is not null or undefined
            assertParamExists('followProfile', 'targetUserId', targetUserId)
            const localVarPath = `/api/v1/users/source/{sourceUserId}/follow/target/{targetUserId}`
                .replace(`{${"sourceUserId"}}`, encodeURIComponent(String(sourceUserId)))
                .replace(`{${"targetUserId"}}`, encodeURIComponent(String(targetUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FollowProfileApi - functional programming interface
 * @export
 */
export const FollowProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FollowProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client to accept a follow request from a source a user profile
         * @summary Accepts a user\'s follow request
         * @param {string} followRecordId The id of the follow record | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptFollowProfile(followRecordId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcceptFollowProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptFollowProfile(followRecordId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FollowProfileApi.acceptFollowProfile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to follow a user profile
         * @summary follow a user profile
         * @param {string} sourceUserId the user ID trying to follow another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} targetUserId the user ID being followed by another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followProfile(sourceUserId: string, targetUserId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FollowProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followProfile(sourceUserId, targetUserId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FollowProfileApi.followProfile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FollowProfileApi - factory interface
 * @export
 */
export const FollowProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FollowProfileApiFp(configuration)
    return {
        /**
         * This endpoint enables a client to accept a follow request from a source a user profile
         * @summary Accepts a user\'s follow request
         * @param {string} followRecordId The id of the follow record | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFollowProfile(followRecordId: string, options?: any): AxiosPromise<AcceptFollowProfileResponse> {
            return localVarFp.acceptFollowProfile(followRecordId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to follow a user profile
         * @summary follow a user profile
         * @param {string} sourceUserId the user ID trying to follow another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} targetUserId the user ID being followed by another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followProfile(sourceUserId: string, targetUserId: string, options?: any): AxiosPromise<FollowProfileResponse> {
            return localVarFp.followProfile(sourceUserId, targetUserId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FollowProfileApi - object-oriented interface
 * @export
 * @class FollowProfileApi
 * @extends {BaseAPI}
 */
export class FollowProfileApi extends BaseAPI {
    /**
     * This endpoint enables a client to accept a follow request from a source a user profile
     * @summary Accepts a user\'s follow request
     * @param {string} followRecordId The id of the follow record | type: uint64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowProfileApi
     */
    public acceptFollowProfile(followRecordId: string, options?: AxiosRequestConfig) {
        return FollowProfileApiFp(this.configuration).acceptFollowProfile(followRecordId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to follow a user profile
     * @summary follow a user profile
     * @param {string} sourceUserId the user ID trying to follow another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {string} targetUserId the user ID being followed by another user (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowProfileApi
     */
    public followProfile(sourceUserId: string, targetUserId: string, options?: AxiosRequestConfig) {
        return FollowProfileApiFp(this.configuration).followProfile(sourceUserId, targetUserId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NoteApi - axios parameter creator
 * @export
 */
export const NoteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client to create and associate a not to a post
         * @summary Creates and associates a note to a given post
         * @param {string} userId 
         * @param {string} postId 
         * @param {CreateNoteBody} createNoteBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNote: async (userId: string, postId: string, createNoteBody: CreateNoteBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createNote', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('createNote', 'postId', postId)
            // verify required parameter 'createNoteBody' is not null or undefined
            assertParamExists('createNote', 'createNoteBody', createNoteBody)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/note`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNoteBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to delete a note
         * @summary Delete a note
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} noteId 
         * @param {DeleteNotePostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNote: async (userId: string, postId: string, noteId: string, postType: DeleteNotePostTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteNote', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('deleteNote', 'postId', postId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('deleteNote', 'noteId', noteId)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('deleteNote', 'postType', postType)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/note/{noteId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (postType !== undefined) {
                localVarQueryParameter['postType'] = postType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to update a note
         * @summary Update a note
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} noteId 
         * @param {EditNotePostTypeEnum} postType 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNote: async (userId: string, postId: string, noteId: string, postType: EditNotePostTypeEnum, note: Note, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('editNote', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('editNote', 'postId', postId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('editNote', 'noteId', noteId)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('editNote', 'postType', postType)
            // verify required parameter 'note' is not null or undefined
            assertParamExists('editNote', 'note', note)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/note/{noteId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (postType !== undefined) {
                localVarQueryParameter['postType'] = postType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(note, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NoteApi - functional programming interface
 * @export
 */
export const NoteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NoteApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client to create and associate a not to a post
         * @summary Creates and associates a note to a given post
         * @param {string} userId 
         * @param {string} postId 
         * @param {CreateNoteBody} createNoteBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNote(userId: string, postId: string, createNoteBody: CreateNoteBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateNoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNote(userId, postId, createNoteBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NoteApi.createNote']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to delete a note
         * @summary Delete a note
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} noteId 
         * @param {DeleteNotePostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNote(userId: string, postId: string, noteId: string, postType: DeleteNotePostTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteNoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNote(userId, postId, noteId, postType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NoteApi.deleteNote']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to update a note
         * @summary Update a note
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} noteId 
         * @param {EditNotePostTypeEnum} postType 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNote(userId: string, postId: string, noteId: string, postType: EditNotePostTypeEnum, note: Note, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditNoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNote(userId, postId, noteId, postType, note, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NoteApi.editNote']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * NoteApi - factory interface
 * @export
 */
export const NoteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NoteApiFp(configuration)
    return {
        /**
         * This endpoint enables a client to create and associate a not to a post
         * @summary Creates and associates a note to a given post
         * @param {string} userId 
         * @param {string} postId 
         * @param {CreateNoteBody} createNoteBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNote(userId: string, postId: string, createNoteBody: CreateNoteBody, options?: any): AxiosPromise<CreateNoteResponse> {
            return localVarFp.createNote(userId, postId, createNoteBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to delete a note
         * @summary Delete a note
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} noteId 
         * @param {DeleteNotePostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNote(userId: string, postId: string, noteId: string, postType: DeleteNotePostTypeEnum, options?: any): AxiosPromise<DeleteNoteResponse> {
            return localVarFp.deleteNote(userId, postId, noteId, postType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to update a note
         * @summary Update a note
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} noteId 
         * @param {EditNotePostTypeEnum} postType 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNote(userId: string, postId: string, noteId: string, postType: EditNotePostTypeEnum, note: Note, options?: any): AxiosPromise<EditNoteResponse> {
            return localVarFp.editNote(userId, postId, noteId, postType, note, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NoteApi - object-oriented interface
 * @export
 * @class NoteApi
 * @extends {BaseAPI}
 */
export class NoteApi extends BaseAPI {
    /**
     * This endpoint enables a client to create and associate a not to a post
     * @summary Creates and associates a note to a given post
     * @param {string} userId 
     * @param {string} postId 
     * @param {CreateNoteBody} createNoteBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteApi
     */
    public createNote(userId: string, postId: string, createNoteBody: CreateNoteBody, options?: AxiosRequestConfig) {
        return NoteApiFp(this.configuration).createNote(userId, postId, createNoteBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to delete a note
     * @summary Delete a note
     * @param {string} userId 
     * @param {string} postId 
     * @param {string} noteId 
     * @param {DeleteNotePostTypeEnum} postType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteApi
     */
    public deleteNote(userId: string, postId: string, noteId: string, postType: DeleteNotePostTypeEnum, options?: AxiosRequestConfig) {
        return NoteApiFp(this.configuration).deleteNote(userId, postId, noteId, postType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to update a note
     * @summary Update a note
     * @param {string} userId 
     * @param {string} postId 
     * @param {string} noteId 
     * @param {EditNotePostTypeEnum} postType 
     * @param {Note} note 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteApi
     */
    public editNote(userId: string, postId: string, noteId: string, postType: EditNotePostTypeEnum, note: Note, options?: AxiosRequestConfig) {
        return NoteApiFp(this.configuration).editNote(userId, postId, noteId, postType, note, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeleteNotePostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type DeleteNotePostTypeEnum = typeof DeleteNotePostTypeEnum[keyof typeof DeleteNotePostTypeEnum];
/**
 * @export
 */
export const EditNotePostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type EditNotePostTypeEnum = typeof EditNotePostTypeEnum[keyof typeof EditNotePostTypeEnum];


/**
 * PollApi - axios parameter creator
 * @export
 */
export const PollApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client to create a poll
         * @summary Create a poll
         * @param {string} userId the user ID trying to create a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {PollPost} pollPost The post payload | type: json_object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPoll: async (userId: string, pollPost: PollPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createPoll', 'userId', userId)
            // verify required parameter 'pollPost' is not null or undefined
            assertParamExists('createPoll', 'pollPost', pollPost)
            const localVarPath = `/api/v1/users/{userId}/poll`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pollPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to delete a poll
         * @summary Delete a poll
         * @param {string} userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} postId The ID of the post attempted to be delete | type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePoll: async (userId: string, postId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deletePoll', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('deletePoll', 'postId', postId)
            const localVarPath = `/api/v1/users/{userId}/poll/{postId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to query a poll by id
         * @summary Get a poll
         * @param {string} userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} postId The ID of the post attempted to be delete | type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoll: async (userId: string, postId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getPoll', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('getPoll', 'postId', postId)
            const localVarPath = `/api/v1/users/{userId}/poll/{postId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to query all polls tied to a given user id
         * @summary Get all the polls of a given user
         * @param {string} userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolls: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getPolls', 'userId', userId)
            const localVarPath = `/api/v1/users/{userId}/polls`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to response to a poll
         * @summary Adds a user response to a given poll by a user
         * @param {string} userId 
         * @param {string} pollId 
         * @param {RespondToPollBody} respondToPollBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondToPoll: async (userId: string, pollId: string, respondToPollBody: RespondToPollBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('respondToPoll', 'userId', userId)
            // verify required parameter 'pollId' is not null or undefined
            assertParamExists('respondToPoll', 'pollId', pollId)
            // verify required parameter 'respondToPollBody' is not null or undefined
            assertParamExists('respondToPoll', 'respondToPollBody', respondToPollBody)
            const localVarPath = `/api/v1/users/{userId}/poll/{pollId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"pollId"}}`, encodeURIComponent(String(pollId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(respondToPollBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PollApi - functional programming interface
 * @export
 */
export const PollApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PollApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client to create a poll
         * @summary Create a poll
         * @param {string} userId the user ID trying to create a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {PollPost} pollPost The post payload | type: json_object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPoll(userId: string, pollPost: PollPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePollResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPoll(userId, pollPost, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PollApi.createPoll']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to delete a poll
         * @summary Delete a poll
         * @param {string} userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} postId The ID of the post attempted to be delete | type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePoll(userId: string, postId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletePollResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePoll(userId, postId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PollApi.deletePoll']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to query a poll by id
         * @summary Get a poll
         * @param {string} userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} postId The ID of the post attempted to be delete | type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPoll(userId: string, postId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPollResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPoll(userId, postId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PollApi.getPoll']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to query all polls tied to a given user id
         * @summary Get all the polls of a given user
         * @param {string} userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolls(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPollsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolls(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PollApi.getPolls']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to response to a poll
         * @summary Adds a user response to a given poll by a user
         * @param {string} userId 
         * @param {string} pollId 
         * @param {RespondToPollBody} respondToPollBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async respondToPoll(userId: string, pollId: string, respondToPollBody: RespondToPollBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RespondToPollResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.respondToPoll(userId, pollId, respondToPollBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PollApi.respondToPoll']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PollApi - factory interface
 * @export
 */
export const PollApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PollApiFp(configuration)
    return {
        /**
         * This endpoint enables a client to create a poll
         * @summary Create a poll
         * @param {string} userId the user ID trying to create a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {PollPost} pollPost The post payload | type: json_object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPoll(userId: string, pollPost: PollPost, options?: any): AxiosPromise<CreatePollResponse> {
            return localVarFp.createPoll(userId, pollPost, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to delete a poll
         * @summary Delete a poll
         * @param {string} userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} postId The ID of the post attempted to be delete | type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePoll(userId: string, postId: string, options?: any): AxiosPromise<DeletePollResponse> {
            return localVarFp.deletePoll(userId, postId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to query a poll by id
         * @summary Get a poll
         * @param {string} userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} postId The ID of the post attempted to be delete | type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoll(userId: string, postId: string, options?: any): AxiosPromise<GetPollResponse> {
            return localVarFp.getPoll(userId, postId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to query all polls tied to a given user id
         * @summary Get all the polls of a given user
         * @param {string} userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolls(userId: string, options?: any): AxiosPromise<GetPollsResponse> {
            return localVarFp.getPolls(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to response to a poll
         * @summary Adds a user response to a given poll by a user
         * @param {string} userId 
         * @param {string} pollId 
         * @param {RespondToPollBody} respondToPollBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondToPoll(userId: string, pollId: string, respondToPollBody: RespondToPollBody, options?: any): AxiosPromise<RespondToPollResponse> {
            return localVarFp.respondToPoll(userId, pollId, respondToPollBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PollApi - object-oriented interface
 * @export
 * @class PollApi
 * @extends {BaseAPI}
 */
export class PollApi extends BaseAPI {
    /**
     * This endpoint enables a client to create a poll
     * @summary Create a poll
     * @param {string} userId the user ID trying to create a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {PollPost} pollPost The post payload | type: json_object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApi
     */
    public createPoll(userId: string, pollPost: PollPost, options?: AxiosRequestConfig) {
        return PollApiFp(this.configuration).createPoll(userId, pollPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to delete a poll
     * @summary Delete a poll
     * @param {string} userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {string} postId The ID of the post attempted to be delete | type: string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApi
     */
    public deletePoll(userId: string, postId: string, options?: AxiosRequestConfig) {
        return PollApiFp(this.configuration).deletePoll(userId, postId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to query a poll by id
     * @summary Get a poll
     * @param {string} userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {string} postId The ID of the post attempted to be delete | type: string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApi
     */
    public getPoll(userId: string, postId: string, options?: AxiosRequestConfig) {
        return PollApiFp(this.configuration).getPoll(userId, postId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to query all polls tied to a given user id
     * @summary Get all the polls of a given user
     * @param {string} userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApi
     */
    public getPolls(userId: string, options?: AxiosRequestConfig) {
        return PollApiFp(this.configuration).getPolls(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to response to a poll
     * @summary Adds a user response to a given poll by a user
     * @param {string} userId 
     * @param {string} pollId 
     * @param {RespondToPollBody} respondToPollBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApi
     */
    public respondToPoll(userId: string, pollId: string, respondToPollBody: RespondToPollBody, options?: AxiosRequestConfig) {
        return PollApiFp(this.configuration).respondToPoll(userId, pollId, respondToPollBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PostApi - axios parameter creator
 * @export
 */
export const PostApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client add a quality score to a post
         * @summary Adds a quality score to a post
         * @param {string} userId 
         * @param {string} postId 
         * @param {AddPostQualityScorePostTypeEnum} postType The type of post being reacted to | type: string
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPostQualityScore: async (userId: string, postId: string, postType: AddPostQualityScorePostTypeEnum, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addPostQualityScore', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('addPostQualityScore', 'postId', postId)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('addPostQualityScore', 'postType', postType)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addPostQualityScore', 'body', body)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/quality`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (postType !== undefined) {
                localVarQueryParameter['postType'] = postType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to create a post
         * @summary Create a post
         * @param {string} userId the user ID trying to create a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {CreatePostAccountTypeEnum} accountType The type of profile making the request | type: string
         * @param {Post} post The post payload | type: json_object
         * @param {string} [communityProfileId] The ID of the community profile attempting to create the post  | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPost: async (userId: string, accountType: CreatePostAccountTypeEnum, post: Post, communityProfileId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createPost', 'userId', userId)
            // verify required parameter 'accountType' is not null or undefined
            assertParamExists('createPost', 'accountType', accountType)
            // verify required parameter 'post' is not null or undefined
            assertParamExists('createPost', 'post', post)
            const localVarPath = `/api/v1/users/{userId}/post`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (communityProfileId !== undefined) {
                localVarQueryParameter['communityProfileId'] = communityProfileId;
            }

            if (accountType !== undefined) {
                localVarQueryParameter['accountType'] = accountType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(post, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to delete a post
         * @summary Delete a post
         * @param {string} userId the user ID trying to delete a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} postId The ID of the post attempted to be delete | type: string
         * @param {DeletePostPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePost: async (userId: string, postId: string, postType: DeletePostPostTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deletePost', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('deletePost', 'postId', postId)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('deletePost', 'postType', postType)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/type/{postType}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"postType"}}`, encodeURIComponent(String(postType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to edit a post by id
         * @summary Edits a post by id
         * @param {string} postId The ID of the post to be updated | type: string
         * @param {EditPostPostTypeEnum} postType 
         * @param {Post} post The post payload | type: json_object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPost: async (postId: string, postType: EditPostPostTypeEnum, post: Post, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('editPost', 'postId', postId)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('editPost', 'postType', postType)
            // verify required parameter 'post' is not null or undefined
            assertParamExists('editPost', 'post', post)
            const localVarPath = `/api/v1/post/{postId}/type/{postType}`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"postType"}}`, encodeURIComponent(String(postType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(post, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to query a set of blog posts tied to a tag
         * @summary Get blog posts by tag
         * @param {string} tag 
         * @param {GetBlogPostsByTagPostTypeEnum} postType The type of post being reacted to | type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogPostsByTag: async (tag: string, postType: GetBlogPostsByTagPostTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getBlogPostsByTag', 'tag', tag)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('getBlogPostsByTag', 'postType', postType)
            const localVarPath = `/api/v1/posts/blog/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (postType !== undefined) {
                localVarQueryParameter['postType'] = postType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to get community blog posts
         * @summary Get community blog posts
         * @param {string} communityProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunityBlogPosts: async (communityProfileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'communityProfileId' is not null or undefined
            assertParamExists('getCommunityBlogPosts', 'communityProfileId', communityProfileId)
            const localVarPath = `/api/v1/community-profiles/{communityProfileId}/posts/blog`
                .replace(`{${"communityProfileId"}}`, encodeURIComponent(String(communityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to get a post
         * @summary Get a post
         * @param {string} userId the user ID trying to obtain a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} postId The ID of the post to obtain | type: string
         * @param {GetPostPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPost: async (userId: string, postId: string, postType: GetPostPostTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getPost', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('getPost', 'postId', postId)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('getPost', 'postType', postType)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/type/{postType}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"postType"}}`, encodeURIComponent(String(postType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to get all posts tied to a topic
         * @summary Get all posts associated with a topic
         * @param {string} communityProfileId the community profile to associate the topic to | type: uint64
         * @param {string} topicName the name of a given topic | type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostsByTopic: async (communityProfileId: string, topicName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'communityProfileId' is not null or undefined
            assertParamExists('getPostsByTopic', 'communityProfileId', communityProfileId)
            // verify required parameter 'topicName' is not null or undefined
            assertParamExists('getPostsByTopic', 'topicName', topicName)
            const localVarPath = `/api/v1/community/{communityProfileId}/topic/{topicName}/posts`
                .replace(`{${"communityProfileId"}}`, encodeURIComponent(String(communityProfileId)))
                .replace(`{${"topicName"}}`, encodeURIComponent(String(topicName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to report a post
         * @summary Report a post
         * @param {string} userId 
         * @param {string} postId 
         * @param {ReportPostPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPost: async (userId: string, postId: string, postType: ReportPostPostTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('reportPost', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('reportPost', 'postId', postId)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('reportPost', 'postType', postType)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/type/{postType}/report`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"postType"}}`, encodeURIComponent(String(postType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostApi - functional programming interface
 * @export
 */
export const PostApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PostApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client add a quality score to a post
         * @summary Adds a quality score to a post
         * @param {string} userId 
         * @param {string} postId 
         * @param {AddPostQualityScorePostTypeEnum} postType The type of post being reacted to | type: string
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPostQualityScore(userId: string, postId: string, postType: AddPostQualityScorePostTypeEnum, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddPostQualityScoreResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPostQualityScore(userId, postId, postType, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PostApi.addPostQualityScore']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to create a post
         * @summary Create a post
         * @param {string} userId the user ID trying to create a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {CreatePostAccountTypeEnum} accountType The type of profile making the request | type: string
         * @param {Post} post The post payload | type: json_object
         * @param {string} [communityProfileId] The ID of the community profile attempting to create the post  | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPost(userId: string, accountType: CreatePostAccountTypeEnum, post: Post, communityProfileId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPost(userId, accountType, post, communityProfileId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PostApi.createPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to delete a post
         * @summary Delete a post
         * @param {string} userId the user ID trying to delete a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} postId The ID of the post attempted to be delete | type: string
         * @param {DeletePostPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePost(userId: string, postId: string, postType: DeletePostPostTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletePostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePost(userId, postId, postType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PostApi.deletePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to edit a post by id
         * @summary Edits a post by id
         * @param {string} postId The ID of the post to be updated | type: string
         * @param {EditPostPostTypeEnum} postType 
         * @param {Post} post The post payload | type: json_object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editPost(postId: string, postType: EditPostPostTypeEnum, post: Post, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editPost(postId, postType, post, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PostApi.editPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to query a set of blog posts tied to a tag
         * @summary Get blog posts by tag
         * @param {string} tag 
         * @param {GetBlogPostsByTagPostTypeEnum} postType The type of post being reacted to | type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlogPostsByTag(tag: string, postType: GetBlogPostsByTagPostTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBlogPostsByTagResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlogPostsByTag(tag, postType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PostApi.getBlogPostsByTag']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to get community blog posts
         * @summary Get community blog posts
         * @param {string} communityProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommunityBlogPosts(communityProfileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCommunityBlogPostsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommunityBlogPosts(communityProfileId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PostApi.getCommunityBlogPosts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to get a post
         * @summary Get a post
         * @param {string} userId the user ID trying to obtain a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} postId The ID of the post to obtain | type: string
         * @param {GetPostPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPost(userId: string, postId: string, postType: GetPostPostTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPost(userId, postId, postType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PostApi.getPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to get all posts tied to a topic
         * @summary Get all posts associated with a topic
         * @param {string} communityProfileId the community profile to associate the topic to | type: uint64
         * @param {string} topicName the name of a given topic | type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostsByTopic(communityProfileId: string, topicName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPostsByTopicResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostsByTopic(communityProfileId, topicName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PostApi.getPostsByTopic']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to report a post
         * @summary Report a post
         * @param {string} userId 
         * @param {string} postId 
         * @param {ReportPostPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportPost(userId: string, postId: string, postType: ReportPostPostTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportPost(userId, postId, postType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PostApi.reportPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PostApi - factory interface
 * @export
 */
export const PostApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PostApiFp(configuration)
    return {
        /**
         * This endpoint enables a client add a quality score to a post
         * @summary Adds a quality score to a post
         * @param {string} userId 
         * @param {string} postId 
         * @param {AddPostQualityScorePostTypeEnum} postType The type of post being reacted to | type: string
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPostQualityScore(userId: string, postId: string, postType: AddPostQualityScorePostTypeEnum, body: string, options?: any): AxiosPromise<AddPostQualityScoreResponse> {
            return localVarFp.addPostQualityScore(userId, postId, postType, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to create a post
         * @summary Create a post
         * @param {string} userId the user ID trying to create a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {CreatePostAccountTypeEnum} accountType The type of profile making the request | type: string
         * @param {Post} post The post payload | type: json_object
         * @param {string} [communityProfileId] The ID of the community profile attempting to create the post  | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPost(userId: string, accountType: CreatePostAccountTypeEnum, post: Post, communityProfileId?: string, options?: any): AxiosPromise<CreatePostResponse> {
            return localVarFp.createPost(userId, accountType, post, communityProfileId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to delete a post
         * @summary Delete a post
         * @param {string} userId the user ID trying to delete a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} postId The ID of the post attempted to be delete | type: string
         * @param {DeletePostPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePost(userId: string, postId: string, postType: DeletePostPostTypeEnum, options?: any): AxiosPromise<DeletePostResponse> {
            return localVarFp.deletePost(userId, postId, postType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to edit a post by id
         * @summary Edits a post by id
         * @param {string} postId The ID of the post to be updated | type: string
         * @param {EditPostPostTypeEnum} postType 
         * @param {Post} post The post payload | type: json_object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPost(postId: string, postType: EditPostPostTypeEnum, post: Post, options?: any): AxiosPromise<EditPostResponse> {
            return localVarFp.editPost(postId, postType, post, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to query a set of blog posts tied to a tag
         * @summary Get blog posts by tag
         * @param {string} tag 
         * @param {GetBlogPostsByTagPostTypeEnum} postType The type of post being reacted to | type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogPostsByTag(tag: string, postType: GetBlogPostsByTagPostTypeEnum, options?: any): AxiosPromise<GetBlogPostsByTagResponse> {
            return localVarFp.getBlogPostsByTag(tag, postType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to get community blog posts
         * @summary Get community blog posts
         * @param {string} communityProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunityBlogPosts(communityProfileId: string, options?: any): AxiosPromise<GetCommunityBlogPostsResponse> {
            return localVarFp.getCommunityBlogPosts(communityProfileId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to get a post
         * @summary Get a post
         * @param {string} userId the user ID trying to obtain a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} postId The ID of the post to obtain | type: string
         * @param {GetPostPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPost(userId: string, postId: string, postType: GetPostPostTypeEnum, options?: any): AxiosPromise<GetPostResponse> {
            return localVarFp.getPost(userId, postId, postType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to get all posts tied to a topic
         * @summary Get all posts associated with a topic
         * @param {string} communityProfileId the community profile to associate the topic to | type: uint64
         * @param {string} topicName the name of a given topic | type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostsByTopic(communityProfileId: string, topicName: string, options?: any): AxiosPromise<GetPostsByTopicResponse> {
            return localVarFp.getPostsByTopic(communityProfileId, topicName, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to report a post
         * @summary Report a post
         * @param {string} userId 
         * @param {string} postId 
         * @param {ReportPostPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPost(userId: string, postId: string, postType: ReportPostPostTypeEnum, options?: any): AxiosPromise<ReportPostResponse> {
            return localVarFp.reportPost(userId, postId, postType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostApi - object-oriented interface
 * @export
 * @class PostApi
 * @extends {BaseAPI}
 */
export class PostApi extends BaseAPI {
    /**
     * This endpoint enables a client add a quality score to a post
     * @summary Adds a quality score to a post
     * @param {string} userId 
     * @param {string} postId 
     * @param {AddPostQualityScorePostTypeEnum} postType The type of post being reacted to | type: string
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public addPostQualityScore(userId: string, postId: string, postType: AddPostQualityScorePostTypeEnum, body: string, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).addPostQualityScore(userId, postId, postType, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to create a post
     * @summary Create a post
     * @param {string} userId the user ID trying to create a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {CreatePostAccountTypeEnum} accountType The type of profile making the request | type: string
     * @param {Post} post The post payload | type: json_object
     * @param {string} [communityProfileId] The ID of the community profile attempting to create the post  | type: uint64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public createPost(userId: string, accountType: CreatePostAccountTypeEnum, post: Post, communityProfileId?: string, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).createPost(userId, accountType, post, communityProfileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to delete a post
     * @summary Delete a post
     * @param {string} userId the user ID trying to delete a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {string} postId The ID of the post attempted to be delete | type: string
     * @param {DeletePostPostTypeEnum} postType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public deletePost(userId: string, postId: string, postType: DeletePostPostTypeEnum, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).deletePost(userId, postId, postType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to edit a post by id
     * @summary Edits a post by id
     * @param {string} postId The ID of the post to be updated | type: string
     * @param {EditPostPostTypeEnum} postType 
     * @param {Post} post The post payload | type: json_object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public editPost(postId: string, postType: EditPostPostTypeEnum, post: Post, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).editPost(postId, postType, post, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to query a set of blog posts tied to a tag
     * @summary Get blog posts by tag
     * @param {string} tag 
     * @param {GetBlogPostsByTagPostTypeEnum} postType The type of post being reacted to | type: string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public getBlogPostsByTag(tag: string, postType: GetBlogPostsByTagPostTypeEnum, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).getBlogPostsByTag(tag, postType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to get community blog posts
     * @summary Get community blog posts
     * @param {string} communityProfileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public getCommunityBlogPosts(communityProfileId: string, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).getCommunityBlogPosts(communityProfileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to get a post
     * @summary Get a post
     * @param {string} userId the user ID trying to obtain a post (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {string} postId The ID of the post to obtain | type: string
     * @param {GetPostPostTypeEnum} postType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public getPost(userId: string, postId: string, postType: GetPostPostTypeEnum, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).getPost(userId, postId, postType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to get all posts tied to a topic
     * @summary Get all posts associated with a topic
     * @param {string} communityProfileId the community profile to associate the topic to | type: uint64
     * @param {string} topicName the name of a given topic | type: string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public getPostsByTopic(communityProfileId: string, topicName: string, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).getPostsByTopic(communityProfileId, topicName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to report a post
     * @summary Report a post
     * @param {string} userId 
     * @param {string} postId 
     * @param {ReportPostPostTypeEnum} postType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public reportPost(userId: string, postId: string, postType: ReportPostPostTypeEnum, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).reportPost(userId, postId, postType, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AddPostQualityScorePostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type AddPostQualityScorePostTypeEnum = typeof AddPostQualityScorePostTypeEnum[keyof typeof AddPostQualityScorePostTypeEnum];
/**
 * @export
 */
export const CreatePostAccountTypeEnum = {
    Unspecified: 'ACCOUNT_TYPE_UNSPECIFIED',
    User: 'ACCOUNT_TYPE_USER',
    Community: 'ACCOUNT_TYPE_COMMUNITY'
} as const;
export type CreatePostAccountTypeEnum = typeof CreatePostAccountTypeEnum[keyof typeof CreatePostAccountTypeEnum];
/**
 * @export
 */
export const DeletePostPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type DeletePostPostTypeEnum = typeof DeletePostPostTypeEnum[keyof typeof DeletePostPostTypeEnum];
/**
 * @export
 */
export const EditPostPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type EditPostPostTypeEnum = typeof EditPostPostTypeEnum[keyof typeof EditPostPostTypeEnum];
/**
 * @export
 */
export const GetBlogPostsByTagPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type GetBlogPostsByTagPostTypeEnum = typeof GetBlogPostsByTagPostTypeEnum[keyof typeof GetBlogPostsByTagPostTypeEnum];
/**
 * @export
 */
export const GetPostPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type GetPostPostTypeEnum = typeof GetPostPostTypeEnum[keyof typeof GetPostPostTypeEnum];
/**
 * @export
 */
export const ReportPostPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type ReportPostPostTypeEnum = typeof ReportPostPostTypeEnum[keyof typeof ReportPostPostTypeEnum];


/**
 * PublicationApi - axios parameter creator
 * @export
 */
export const PublicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client to add a post to a publication
         * @summary Add a post to a publication
         * @param {string} editorUserId 
         * @param {string} publicationId 
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPostToPublication: async (editorUserId: string, publicationId: string, post: Post, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editorUserId' is not null or undefined
            assertParamExists('addPostToPublication', 'editorUserId', editorUserId)
            // verify required parameter 'publicationId' is not null or undefined
            assertParamExists('addPostToPublication', 'publicationId', publicationId)
            // verify required parameter 'post' is not null or undefined
            assertParamExists('addPostToPublication', 'post', post)
            const localVarPath = `/api/v1/users/editor/{editorUserId}/publication/{publicationId}`
                .replace(`{${"editorUserId"}}`, encodeURIComponent(String(editorUserId)))
                .replace(`{${"publicationId"}}`, encodeURIComponent(String(publicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(post, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to add an editor to a publication
         * @summary Adds an editor to a publication
         * @param {string} adminUserId 
         * @param {string} publicationId 
         * @param {string} editorUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPublicationEditor: async (adminUserId: string, publicationId: string, editorUserId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminUserId' is not null or undefined
            assertParamExists('addPublicationEditor', 'adminUserId', adminUserId)
            // verify required parameter 'publicationId' is not null or undefined
            assertParamExists('addPublicationEditor', 'publicationId', publicationId)
            // verify required parameter 'editorUserId' is not null or undefined
            assertParamExists('addPublicationEditor', 'editorUserId', editorUserId)
            const localVarPath = `/api/v1/users/admin/{adminUserId}/publication/{publicationId}/editor/{editorUserId}`
                .replace(`{${"adminUserId"}}`, encodeURIComponent(String(adminUserId)))
                .replace(`{${"publicationId"}}`, encodeURIComponent(String(publicationId)))
                .replace(`{${"editorUserId"}}`, encodeURIComponent(String(editorUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to creare a publication
         * @summary Creates a publication
         * @param {string} userId 
         * @param {Publication} publication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublication: async (userId: string, publication: Publication, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createPublication', 'userId', userId)
            // verify required parameter 'publication' is not null or undefined
            assertParamExists('createPublication', 'publication', publication)
            const localVarPath = `/api/v1/users/{userId}/publication`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publication, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to delete a post from a publication
         * @summary Deletes a post from a publication
         * @param {string} editorUserId 
         * @param {string} publicationId 
         * @param {string} postId 
         * @param {DeletePostFromPublicationPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostFromPublication: async (editorUserId: string, publicationId: string, postId: string, postType: DeletePostFromPublicationPostTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editorUserId' is not null or undefined
            assertParamExists('deletePostFromPublication', 'editorUserId', editorUserId)
            // verify required parameter 'publicationId' is not null or undefined
            assertParamExists('deletePostFromPublication', 'publicationId', publicationId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('deletePostFromPublication', 'postId', postId)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('deletePostFromPublication', 'postType', postType)
            const localVarPath = `/api/v1/users/editor/{editorUserId}/publication/{publicationId}/post/{postId}`
                .replace(`{${"editorUserId"}}`, encodeURIComponent(String(editorUserId)))
                .replace(`{${"publicationId"}}`, encodeURIComponent(String(publicationId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (postType !== undefined) {
                localVarQueryParameter['postType'] = postType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to delete a publication
         * @summary Deletes a publication
         * @param {string} adminUserId 
         * @param {string} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublication: async (adminUserId: string, publicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminUserId' is not null or undefined
            assertParamExists('deletePublication', 'adminUserId', adminUserId)
            // verify required parameter 'publicationId' is not null or undefined
            assertParamExists('deletePublication', 'publicationId', publicationId)
            const localVarPath = `/api/v1/users/admin/{adminUserId}/publication/{publicationId}`
                .replace(`{${"adminUserId"}}`, encodeURIComponent(String(adminUserId)))
                .replace(`{${"publicationId"}}`, encodeURIComponent(String(publicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to add an editor to a publication
         * @summary Deletes an editor to a publication
         * @param {string} adminUserId 
         * @param {string} publicationId 
         * @param {string} editorUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicationEditor: async (adminUserId: string, publicationId: string, editorUserId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminUserId' is not null or undefined
            assertParamExists('deletePublicationEditor', 'adminUserId', adminUserId)
            // verify required parameter 'publicationId' is not null or undefined
            assertParamExists('deletePublicationEditor', 'publicationId', publicationId)
            // verify required parameter 'editorUserId' is not null or undefined
            assertParamExists('deletePublicationEditor', 'editorUserId', editorUserId)
            const localVarPath = `/api/v1/users/admin/{adminUserId}/publication/{publicationId}/editor/{editorUserId}`
                .replace(`{${"adminUserId"}}`, encodeURIComponent(String(adminUserId)))
                .replace(`{${"publicationId"}}`, encodeURIComponent(String(publicationId)))
                .replace(`{${"editorUserId"}}`, encodeURIComponent(String(editorUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to get a publication
         * @summary Gets a publication
         * @param {string} userId 
         * @param {string} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublication: async (userId: string, publicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getPublication', 'userId', userId)
            // verify required parameter 'publicationId' is not null or undefined
            assertParamExists('getPublication', 'publicationId', publicationId)
            const localVarPath = `/api/v1/users/{userId}/publication/{publicationId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"publicationId"}}`, encodeURIComponent(String(publicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicationApi - functional programming interface
 * @export
 */
export const PublicationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicationApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client to add a post to a publication
         * @summary Add a post to a publication
         * @param {string} editorUserId 
         * @param {string} publicationId 
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPostToPublication(editorUserId: string, publicationId: string, post: Post, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddPostToPublicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPostToPublication(editorUserId, publicationId, post, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PublicationApi.addPostToPublication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to add an editor to a publication
         * @summary Adds an editor to a publication
         * @param {string} adminUserId 
         * @param {string} publicationId 
         * @param {string} editorUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPublicationEditor(adminUserId: string, publicationId: string, editorUserId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddPublicationEditorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPublicationEditor(adminUserId, publicationId, editorUserId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PublicationApi.addPublicationEditor']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to creare a publication
         * @summary Creates a publication
         * @param {string} userId 
         * @param {Publication} publication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublication(userId: string, publication: Publication, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePublicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublication(userId, publication, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PublicationApi.createPublication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to delete a post from a publication
         * @summary Deletes a post from a publication
         * @param {string} editorUserId 
         * @param {string} publicationId 
         * @param {string} postId 
         * @param {DeletePostFromPublicationPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePostFromPublication(editorUserId: string, publicationId: string, postId: string, postType: DeletePostFromPublicationPostTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletePostFromPublicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePostFromPublication(editorUserId, publicationId, postId, postType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PublicationApi.deletePostFromPublication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to delete a publication
         * @summary Deletes a publication
         * @param {string} adminUserId 
         * @param {string} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublication(adminUserId: string, publicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletePublicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublication(adminUserId, publicationId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PublicationApi.deletePublication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to add an editor to a publication
         * @summary Deletes an editor to a publication
         * @param {string} adminUserId 
         * @param {string} publicationId 
         * @param {string} editorUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicationEditor(adminUserId: string, publicationId: string, editorUserId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletePublicationEditorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicationEditor(adminUserId, publicationId, editorUserId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PublicationApi.deletePublicationEditor']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to get a publication
         * @summary Gets a publication
         * @param {string} userId 
         * @param {string} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublication(userId: string, publicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPublicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublication(userId, publicationId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PublicationApi.getPublication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PublicationApi - factory interface
 * @export
 */
export const PublicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicationApiFp(configuration)
    return {
        /**
         * This endpoint enables a client to add a post to a publication
         * @summary Add a post to a publication
         * @param {string} editorUserId 
         * @param {string} publicationId 
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPostToPublication(editorUserId: string, publicationId: string, post: Post, options?: any): AxiosPromise<AddPostToPublicationResponse> {
            return localVarFp.addPostToPublication(editorUserId, publicationId, post, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to add an editor to a publication
         * @summary Adds an editor to a publication
         * @param {string} adminUserId 
         * @param {string} publicationId 
         * @param {string} editorUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPublicationEditor(adminUserId: string, publicationId: string, editorUserId: string, options?: any): AxiosPromise<AddPublicationEditorResponse> {
            return localVarFp.addPublicationEditor(adminUserId, publicationId, editorUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to creare a publication
         * @summary Creates a publication
         * @param {string} userId 
         * @param {Publication} publication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublication(userId: string, publication: Publication, options?: any): AxiosPromise<CreatePublicationResponse> {
            return localVarFp.createPublication(userId, publication, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to delete a post from a publication
         * @summary Deletes a post from a publication
         * @param {string} editorUserId 
         * @param {string} publicationId 
         * @param {string} postId 
         * @param {DeletePostFromPublicationPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostFromPublication(editorUserId: string, publicationId: string, postId: string, postType: DeletePostFromPublicationPostTypeEnum, options?: any): AxiosPromise<DeletePostFromPublicationResponse> {
            return localVarFp.deletePostFromPublication(editorUserId, publicationId, postId, postType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to delete a publication
         * @summary Deletes a publication
         * @param {string} adminUserId 
         * @param {string} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublication(adminUserId: string, publicationId: string, options?: any): AxiosPromise<DeletePublicationResponse> {
            return localVarFp.deletePublication(adminUserId, publicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to add an editor to a publication
         * @summary Deletes an editor to a publication
         * @param {string} adminUserId 
         * @param {string} publicationId 
         * @param {string} editorUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicationEditor(adminUserId: string, publicationId: string, editorUserId: string, options?: any): AxiosPromise<DeletePublicationEditorResponse> {
            return localVarFp.deletePublicationEditor(adminUserId, publicationId, editorUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to get a publication
         * @summary Gets a publication
         * @param {string} userId 
         * @param {string} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublication(userId: string, publicationId: string, options?: any): AxiosPromise<GetPublicationResponse> {
            return localVarFp.getPublication(userId, publicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicationApi - object-oriented interface
 * @export
 * @class PublicationApi
 * @extends {BaseAPI}
 */
export class PublicationApi extends BaseAPI {
    /**
     * This endpoint enables a client to add a post to a publication
     * @summary Add a post to a publication
     * @param {string} editorUserId 
     * @param {string} publicationId 
     * @param {Post} post 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationApi
     */
    public addPostToPublication(editorUserId: string, publicationId: string, post: Post, options?: AxiosRequestConfig) {
        return PublicationApiFp(this.configuration).addPostToPublication(editorUserId, publicationId, post, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to add an editor to a publication
     * @summary Adds an editor to a publication
     * @param {string} adminUserId 
     * @param {string} publicationId 
     * @param {string} editorUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationApi
     */
    public addPublicationEditor(adminUserId: string, publicationId: string, editorUserId: string, options?: AxiosRequestConfig) {
        return PublicationApiFp(this.configuration).addPublicationEditor(adminUserId, publicationId, editorUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to creare a publication
     * @summary Creates a publication
     * @param {string} userId 
     * @param {Publication} publication 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationApi
     */
    public createPublication(userId: string, publication: Publication, options?: AxiosRequestConfig) {
        return PublicationApiFp(this.configuration).createPublication(userId, publication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to delete a post from a publication
     * @summary Deletes a post from a publication
     * @param {string} editorUserId 
     * @param {string} publicationId 
     * @param {string} postId 
     * @param {DeletePostFromPublicationPostTypeEnum} postType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationApi
     */
    public deletePostFromPublication(editorUserId: string, publicationId: string, postId: string, postType: DeletePostFromPublicationPostTypeEnum, options?: AxiosRequestConfig) {
        return PublicationApiFp(this.configuration).deletePostFromPublication(editorUserId, publicationId, postId, postType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to delete a publication
     * @summary Deletes a publication
     * @param {string} adminUserId 
     * @param {string} publicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationApi
     */
    public deletePublication(adminUserId: string, publicationId: string, options?: AxiosRequestConfig) {
        return PublicationApiFp(this.configuration).deletePublication(adminUserId, publicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to add an editor to a publication
     * @summary Deletes an editor to a publication
     * @param {string} adminUserId 
     * @param {string} publicationId 
     * @param {string} editorUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationApi
     */
    public deletePublicationEditor(adminUserId: string, publicationId: string, editorUserId: string, options?: AxiosRequestConfig) {
        return PublicationApiFp(this.configuration).deletePublicationEditor(adminUserId, publicationId, editorUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to get a publication
     * @summary Gets a publication
     * @param {string} userId 
     * @param {string} publicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationApi
     */
    public getPublication(userId: string, publicationId: string, options?: AxiosRequestConfig) {
        return PublicationApiFp(this.configuration).getPublication(userId, publicationId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeletePostFromPublicationPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type DeletePostFromPublicationPostTypeEnum = typeof DeletePostFromPublicationPostTypeEnum[keyof typeof DeletePostFromPublicationPostTypeEnum];


/**
 * ReactionApi - axios parameter creator
 * @export
 */
export const ReactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client to react to a comment
         * @summary Reacts to a comment
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {ReactToCommentAccountTypeEnum} accountType 
         * @param {ReactToCommentReactionEnum} reaction 
         * @param {ReactToCommentPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactToComment: async (userId: string, postId: string, commentId: string, accountType: ReactToCommentAccountTypeEnum, reaction: ReactToCommentReactionEnum, postType: ReactToCommentPostTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('reactToComment', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('reactToComment', 'postId', postId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('reactToComment', 'commentId', commentId)
            // verify required parameter 'accountType' is not null or undefined
            assertParamExists('reactToComment', 'accountType', accountType)
            // verify required parameter 'reaction' is not null or undefined
            assertParamExists('reactToComment', 'reaction', reaction)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('reactToComment', 'postType', postType)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/comment/{commentId}/account-type/{accountType}/reaction/{reaction}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"accountType"}}`, encodeURIComponent(String(accountType)))
                .replace(`{${"reaction"}}`, encodeURIComponent(String(reaction)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (postType !== undefined) {
                localVarQueryParameter['postType'] = postType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to react to a comment reply
         * @summary Reacts to a comment reply
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {string} replyId 
         * @param {ReactToCommentReplyAccountTypeEnum} accountType 
         * @param {ReactToCommentReplyReactionEnum} reaction 
         * @param {ReactToCommentReplyPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactToCommentReply: async (userId: string, postId: string, commentId: string, replyId: string, accountType: ReactToCommentReplyAccountTypeEnum, reaction: ReactToCommentReplyReactionEnum, postType: ReactToCommentReplyPostTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('reactToCommentReply', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('reactToCommentReply', 'postId', postId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('reactToCommentReply', 'commentId', commentId)
            // verify required parameter 'replyId' is not null or undefined
            assertParamExists('reactToCommentReply', 'replyId', replyId)
            // verify required parameter 'accountType' is not null or undefined
            assertParamExists('reactToCommentReply', 'accountType', accountType)
            // verify required parameter 'reaction' is not null or undefined
            assertParamExists('reactToCommentReply', 'reaction', reaction)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('reactToCommentReply', 'postType', postType)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/comment/{commentId}/reply/{replyId}/account-type/{accountType}/reaction/{reaction}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"replyId"}}`, encodeURIComponent(String(replyId)))
                .replace(`{${"accountType"}}`, encodeURIComponent(String(accountType)))
                .replace(`{${"reaction"}}`, encodeURIComponent(String(reaction)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (postType !== undefined) {
                localVarQueryParameter['postType'] = postType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to react to a post
         * @summary Reacts to a post
         * @param {string} userId 
         * @param {string} postId 
         * @param {ReactToPostAccountTypeEnum} accountType 
         * @param {ReactToPostReactionEnum} reaction 
         * @param {ReactToPostPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactToPost: async (userId: string, postId: string, accountType: ReactToPostAccountTypeEnum, reaction: ReactToPostReactionEnum, postType: ReactToPostPostTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('reactToPost', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('reactToPost', 'postId', postId)
            // verify required parameter 'accountType' is not null or undefined
            assertParamExists('reactToPost', 'accountType', accountType)
            // verify required parameter 'reaction' is not null or undefined
            assertParamExists('reactToPost', 'reaction', reaction)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('reactToPost', 'postType', postType)
            const localVarPath = `/api/v1/users/{userId}/post/{postId}/account-type/{accountType}/reaction/{reaction}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"accountType"}}`, encodeURIComponent(String(accountType)))
                .replace(`{${"reaction"}}`, encodeURIComponent(String(reaction)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (postType !== undefined) {
                localVarQueryParameter['postType'] = postType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReactionApi - functional programming interface
 * @export
 */
export const ReactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReactionApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client to react to a comment
         * @summary Reacts to a comment
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {ReactToCommentAccountTypeEnum} accountType 
         * @param {ReactToCommentReactionEnum} reaction 
         * @param {ReactToCommentPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reactToComment(userId: string, postId: string, commentId: string, accountType: ReactToCommentAccountTypeEnum, reaction: ReactToCommentReactionEnum, postType: ReactToCommentPostTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReactToCommentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reactToComment(userId, postId, commentId, accountType, reaction, postType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ReactionApi.reactToComment']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to react to a comment reply
         * @summary Reacts to a comment reply
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {string} replyId 
         * @param {ReactToCommentReplyAccountTypeEnum} accountType 
         * @param {ReactToCommentReplyReactionEnum} reaction 
         * @param {ReactToCommentReplyPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reactToCommentReply(userId: string, postId: string, commentId: string, replyId: string, accountType: ReactToCommentReplyAccountTypeEnum, reaction: ReactToCommentReplyReactionEnum, postType: ReactToCommentReplyPostTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReactToCommentReplyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reactToCommentReply(userId, postId, commentId, replyId, accountType, reaction, postType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ReactionApi.reactToCommentReply']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to react to a post
         * @summary Reacts to a post
         * @param {string} userId 
         * @param {string} postId 
         * @param {ReactToPostAccountTypeEnum} accountType 
         * @param {ReactToPostReactionEnum} reaction 
         * @param {ReactToPostPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reactToPost(userId: string, postId: string, accountType: ReactToPostAccountTypeEnum, reaction: ReactToPostReactionEnum, postType: ReactToPostPostTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReactToPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reactToPost(userId, postId, accountType, reaction, postType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ReactionApi.reactToPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ReactionApi - factory interface
 * @export
 */
export const ReactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReactionApiFp(configuration)
    return {
        /**
         * This endpoint enables a client to react to a comment
         * @summary Reacts to a comment
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {ReactToCommentAccountTypeEnum} accountType 
         * @param {ReactToCommentReactionEnum} reaction 
         * @param {ReactToCommentPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactToComment(userId: string, postId: string, commentId: string, accountType: ReactToCommentAccountTypeEnum, reaction: ReactToCommentReactionEnum, postType: ReactToCommentPostTypeEnum, options?: any): AxiosPromise<ReactToCommentResponse> {
            return localVarFp.reactToComment(userId, postId, commentId, accountType, reaction, postType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to react to a comment reply
         * @summary Reacts to a comment reply
         * @param {string} userId 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {string} replyId 
         * @param {ReactToCommentReplyAccountTypeEnum} accountType 
         * @param {ReactToCommentReplyReactionEnum} reaction 
         * @param {ReactToCommentReplyPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactToCommentReply(userId: string, postId: string, commentId: string, replyId: string, accountType: ReactToCommentReplyAccountTypeEnum, reaction: ReactToCommentReplyReactionEnum, postType: ReactToCommentReplyPostTypeEnum, options?: any): AxiosPromise<ReactToCommentReplyResponse> {
            return localVarFp.reactToCommentReply(userId, postId, commentId, replyId, accountType, reaction, postType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to react to a post
         * @summary Reacts to a post
         * @param {string} userId 
         * @param {string} postId 
         * @param {ReactToPostAccountTypeEnum} accountType 
         * @param {ReactToPostReactionEnum} reaction 
         * @param {ReactToPostPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactToPost(userId: string, postId: string, accountType: ReactToPostAccountTypeEnum, reaction: ReactToPostReactionEnum, postType: ReactToPostPostTypeEnum, options?: any): AxiosPromise<ReactToPostResponse> {
            return localVarFp.reactToPost(userId, postId, accountType, reaction, postType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReactionApi - object-oriented interface
 * @export
 * @class ReactionApi
 * @extends {BaseAPI}
 */
export class ReactionApi extends BaseAPI {
    /**
     * This endpoint enables a client to react to a comment
     * @summary Reacts to a comment
     * @param {string} userId 
     * @param {string} postId 
     * @param {string} commentId 
     * @param {ReactToCommentAccountTypeEnum} accountType 
     * @param {ReactToCommentReactionEnum} reaction 
     * @param {ReactToCommentPostTypeEnum} postType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReactionApi
     */
    public reactToComment(userId: string, postId: string, commentId: string, accountType: ReactToCommentAccountTypeEnum, reaction: ReactToCommentReactionEnum, postType: ReactToCommentPostTypeEnum, options?: AxiosRequestConfig) {
        return ReactionApiFp(this.configuration).reactToComment(userId, postId, commentId, accountType, reaction, postType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to react to a comment reply
     * @summary Reacts to a comment reply
     * @param {string} userId 
     * @param {string} postId 
     * @param {string} commentId 
     * @param {string} replyId 
     * @param {ReactToCommentReplyAccountTypeEnum} accountType 
     * @param {ReactToCommentReplyReactionEnum} reaction 
     * @param {ReactToCommentReplyPostTypeEnum} postType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReactionApi
     */
    public reactToCommentReply(userId: string, postId: string, commentId: string, replyId: string, accountType: ReactToCommentReplyAccountTypeEnum, reaction: ReactToCommentReplyReactionEnum, postType: ReactToCommentReplyPostTypeEnum, options?: AxiosRequestConfig) {
        return ReactionApiFp(this.configuration).reactToCommentReply(userId, postId, commentId, replyId, accountType, reaction, postType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to react to a post
     * @summary Reacts to a post
     * @param {string} userId 
     * @param {string} postId 
     * @param {ReactToPostAccountTypeEnum} accountType 
     * @param {ReactToPostReactionEnum} reaction 
     * @param {ReactToPostPostTypeEnum} postType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReactionApi
     */
    public reactToPost(userId: string, postId: string, accountType: ReactToPostAccountTypeEnum, reaction: ReactToPostReactionEnum, postType: ReactToPostPostTypeEnum, options?: AxiosRequestConfig) {
        return ReactionApiFp(this.configuration).reactToPost(userId, postId, accountType, reaction, postType, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ReactToCommentAccountTypeEnum = {
    Unspecified: 'ACCOUNT_TYPE_UNSPECIFIED',
    User: 'ACCOUNT_TYPE_USER',
    Community: 'ACCOUNT_TYPE_COMMUNITY'
} as const;
export type ReactToCommentAccountTypeEnum = typeof ReactToCommentAccountTypeEnum[keyof typeof ReactToCommentAccountTypeEnum];
/**
 * @export
 */
export const ReactToCommentReactionEnum = {
    Unspecified: 'REACTION_UNSPECIFIED',
    Like: 'REACTION_LIKE',
    Love: 'REACTION_LOVE',
    Haha: 'REACTION_HAHA',
    Wow: 'REACTION_WOW',
    Sad: 'REACTION_SAD',
    Angry: 'REACTION_ANGRY',
    Dislike: 'REACTION_DISLIKE'
} as const;
export type ReactToCommentReactionEnum = typeof ReactToCommentReactionEnum[keyof typeof ReactToCommentReactionEnum];
/**
 * @export
 */
export const ReactToCommentPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type ReactToCommentPostTypeEnum = typeof ReactToCommentPostTypeEnum[keyof typeof ReactToCommentPostTypeEnum];
/**
 * @export
 */
export const ReactToCommentReplyAccountTypeEnum = {
    Unspecified: 'ACCOUNT_TYPE_UNSPECIFIED',
    User: 'ACCOUNT_TYPE_USER',
    Community: 'ACCOUNT_TYPE_COMMUNITY'
} as const;
export type ReactToCommentReplyAccountTypeEnum = typeof ReactToCommentReplyAccountTypeEnum[keyof typeof ReactToCommentReplyAccountTypeEnum];
/**
 * @export
 */
export const ReactToCommentReplyReactionEnum = {
    Unspecified: 'REACTION_UNSPECIFIED',
    Like: 'REACTION_LIKE',
    Love: 'REACTION_LOVE',
    Haha: 'REACTION_HAHA',
    Wow: 'REACTION_WOW',
    Sad: 'REACTION_SAD',
    Angry: 'REACTION_ANGRY',
    Dislike: 'REACTION_DISLIKE'
} as const;
export type ReactToCommentReplyReactionEnum = typeof ReactToCommentReplyReactionEnum[keyof typeof ReactToCommentReplyReactionEnum];
/**
 * @export
 */
export const ReactToCommentReplyPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type ReactToCommentReplyPostTypeEnum = typeof ReactToCommentReplyPostTypeEnum[keyof typeof ReactToCommentReplyPostTypeEnum];
/**
 * @export
 */
export const ReactToPostAccountTypeEnum = {
    Unspecified: 'ACCOUNT_TYPE_UNSPECIFIED',
    User: 'ACCOUNT_TYPE_USER',
    Community: 'ACCOUNT_TYPE_COMMUNITY'
} as const;
export type ReactToPostAccountTypeEnum = typeof ReactToPostAccountTypeEnum[keyof typeof ReactToPostAccountTypeEnum];
/**
 * @export
 */
export const ReactToPostReactionEnum = {
    Unspecified: 'REACTION_UNSPECIFIED',
    Like: 'REACTION_LIKE',
    Love: 'REACTION_LOVE',
    Haha: 'REACTION_HAHA',
    Wow: 'REACTION_WOW',
    Sad: 'REACTION_SAD',
    Angry: 'REACTION_ANGRY',
    Dislike: 'REACTION_DISLIKE'
} as const;
export type ReactToPostReactionEnum = typeof ReactToPostReactionEnum[keyof typeof ReactToPostReactionEnum];
/**
 * @export
 */
export const ReactToPostPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type ReactToPostPostTypeEnum = typeof ReactToPostPostTypeEnum[keyof typeof ReactToPostPostTypeEnum];


/**
 * ServiceHealthApi - axios parameter creator
 * @export
 */
export const ServiceHealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint performs a healc check on the service
         * @summary health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceHealthApi - functional programming interface
 * @export
 */
export const ServiceHealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceHealthApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint performs a healc check on the service
         * @summary health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheck(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceHealthApi.healthCheck']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ServiceHealthApi - factory interface
 * @export
 */
export const ServiceHealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceHealthApiFp(configuration)
    return {
        /**
         * This endpoint performs a healc check on the service
         * @summary health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: any): AxiosPromise<HealthCheckResponse> {
            return localVarFp.healthCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceHealthApi - object-oriented interface
 * @export
 * @class ServiceHealthApi
 * @extends {BaseAPI}
 */
export class ServiceHealthApi extends BaseAPI {
    /**
     * This endpoint performs a healc check on the service
     * @summary health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceHealthApi
     */
    public healthCheck(options?: AxiosRequestConfig) {
        return ServiceHealthApiFp(this.configuration).healthCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServiceReadynessApi - axios parameter creator
 * @export
 */
export const ServiceReadynessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint performs a readiness check on the service
         * @summary readyness check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readynessCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ready`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceReadynessApi - functional programming interface
 * @export
 */
export const ServiceReadynessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceReadynessApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint performs a readiness check on the service
         * @summary readyness check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readynessCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadynessCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readynessCheck(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceReadynessApi.readynessCheck']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ServiceReadynessApi - factory interface
 * @export
 */
export const ServiceReadynessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceReadynessApiFp(configuration)
    return {
        /**
         * This endpoint performs a readiness check on the service
         * @summary readyness check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readynessCheck(options?: any): AxiosPromise<ReadynessCheckResponse> {
            return localVarFp.readynessCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceReadynessApi - object-oriented interface
 * @export
 * @class ServiceReadynessApi
 * @extends {BaseAPI}
 */
export class ServiceReadynessApi extends BaseAPI {
    /**
     * This endpoint performs a readiness check on the service
     * @summary readyness check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceReadynessApi
     */
    public readynessCheck(options?: AxiosRequestConfig) {
        return ServiceReadynessApiFp(this.configuration).readynessCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThreadApi - axios parameter creator
 * @export
 */
export const ThreadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client to add a post to a thread
         * @summary Adds A Post To A Thread
         * @param {string} userId 
         * @param {string} parentPostId 
         * @param {AddPostToThreadPostTypeEnum} postType 
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPostToThread: async (userId: string, parentPostId: string, postType: AddPostToThreadPostTypeEnum, post: Post, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addPostToThread', 'userId', userId)
            // verify required parameter 'parentPostId' is not null or undefined
            assertParamExists('addPostToThread', 'parentPostId', parentPostId)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('addPostToThread', 'postType', postType)
            // verify required parameter 'post' is not null or undefined
            assertParamExists('addPostToThread', 'post', post)
            const localVarPath = `/api/v1/users/{userId}/post/thread/{parentPostId}/type/{postType}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"parentPostId"}}`, encodeURIComponent(String(parentPostId)))
                .replace(`{${"postType"}}`, encodeURIComponent(String(postType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(post, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to query a post\'s thread
         * @summary Gets A Post\'s Thread
         * @param {string} userId 
         * @param {string} postId 
         * @param {GetPostThreadPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostThread: async (userId: string, postId: string, postType: GetPostThreadPostTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getPostThread', 'userId', userId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('getPostThread', 'postId', postId)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('getPostThread', 'postType', postType)
            const localVarPath = `/api/v1/users/{userId}/post/thread/{postId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (postType !== undefined) {
                localVarQueryParameter['postType'] = postType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to delete a post from a thread
         * @summary Deletes A Post From A Thread
         * @param {string} userId 
         * @param {string} parentPostId 
         * @param {RemovePostFromThreadPostTypeEnum} postType 
         * @param {string} participantPostId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePostFromThread: async (userId: string, parentPostId: string, postType: RemovePostFromThreadPostTypeEnum, participantPostId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removePostFromThread', 'userId', userId)
            // verify required parameter 'parentPostId' is not null or undefined
            assertParamExists('removePostFromThread', 'parentPostId', parentPostId)
            // verify required parameter 'postType' is not null or undefined
            assertParamExists('removePostFromThread', 'postType', postType)
            // verify required parameter 'participantPostId' is not null or undefined
            assertParamExists('removePostFromThread', 'participantPostId', participantPostId)
            const localVarPath = `/api/v1/users/{userId}/post/thread/{parentPostId}/type/{postType}/target/{participantPostId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"parentPostId"}}`, encodeURIComponent(String(parentPostId)))
                .replace(`{${"postType"}}`, encodeURIComponent(String(postType)))
                .replace(`{${"participantPostId"}}`, encodeURIComponent(String(participantPostId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThreadApi - functional programming interface
 * @export
 */
export const ThreadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThreadApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client to add a post to a thread
         * @summary Adds A Post To A Thread
         * @param {string} userId 
         * @param {string} parentPostId 
         * @param {AddPostToThreadPostTypeEnum} postType 
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPostToThread(userId: string, parentPostId: string, postType: AddPostToThreadPostTypeEnum, post: Post, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddPostToThreadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPostToThread(userId, parentPostId, postType, post, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ThreadApi.addPostToThread']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to query a post\'s thread
         * @summary Gets A Post\'s Thread
         * @param {string} userId 
         * @param {string} postId 
         * @param {GetPostThreadPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostThread(userId: string, postId: string, postType: GetPostThreadPostTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPostThreadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostThread(userId, postId, postType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ThreadApi.getPostThread']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to delete a post from a thread
         * @summary Deletes A Post From A Thread
         * @param {string} userId 
         * @param {string} parentPostId 
         * @param {RemovePostFromThreadPostTypeEnum} postType 
         * @param {string} participantPostId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePostFromThread(userId: string, parentPostId: string, postType: RemovePostFromThreadPostTypeEnum, participantPostId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemovePostFromThreadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removePostFromThread(userId, parentPostId, postType, participantPostId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ThreadApi.removePostFromThread']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ThreadApi - factory interface
 * @export
 */
export const ThreadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThreadApiFp(configuration)
    return {
        /**
         * This endpoint enables a client to add a post to a thread
         * @summary Adds A Post To A Thread
         * @param {string} userId 
         * @param {string} parentPostId 
         * @param {AddPostToThreadPostTypeEnum} postType 
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPostToThread(userId: string, parentPostId: string, postType: AddPostToThreadPostTypeEnum, post: Post, options?: any): AxiosPromise<AddPostToThreadResponse> {
            return localVarFp.addPostToThread(userId, parentPostId, postType, post, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to query a post\'s thread
         * @summary Gets A Post\'s Thread
         * @param {string} userId 
         * @param {string} postId 
         * @param {GetPostThreadPostTypeEnum} postType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostThread(userId: string, postId: string, postType: GetPostThreadPostTypeEnum, options?: any): AxiosPromise<GetPostThreadResponse> {
            return localVarFp.getPostThread(userId, postId, postType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to delete a post from a thread
         * @summary Deletes A Post From A Thread
         * @param {string} userId 
         * @param {string} parentPostId 
         * @param {RemovePostFromThreadPostTypeEnum} postType 
         * @param {string} participantPostId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePostFromThread(userId: string, parentPostId: string, postType: RemovePostFromThreadPostTypeEnum, participantPostId: string, options?: any): AxiosPromise<RemovePostFromThreadResponse> {
            return localVarFp.removePostFromThread(userId, parentPostId, postType, participantPostId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThreadApi - object-oriented interface
 * @export
 * @class ThreadApi
 * @extends {BaseAPI}
 */
export class ThreadApi extends BaseAPI {
    /**
     * This endpoint enables a client to add a post to a thread
     * @summary Adds A Post To A Thread
     * @param {string} userId 
     * @param {string} parentPostId 
     * @param {AddPostToThreadPostTypeEnum} postType 
     * @param {Post} post 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadApi
     */
    public addPostToThread(userId: string, parentPostId: string, postType: AddPostToThreadPostTypeEnum, post: Post, options?: AxiosRequestConfig) {
        return ThreadApiFp(this.configuration).addPostToThread(userId, parentPostId, postType, post, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to query a post\'s thread
     * @summary Gets A Post\'s Thread
     * @param {string} userId 
     * @param {string} postId 
     * @param {GetPostThreadPostTypeEnum} postType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadApi
     */
    public getPostThread(userId: string, postId: string, postType: GetPostThreadPostTypeEnum, options?: AxiosRequestConfig) {
        return ThreadApiFp(this.configuration).getPostThread(userId, postId, postType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to delete a post from a thread
     * @summary Deletes A Post From A Thread
     * @param {string} userId 
     * @param {string} parentPostId 
     * @param {RemovePostFromThreadPostTypeEnum} postType 
     * @param {string} participantPostId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadApi
     */
    public removePostFromThread(userId: string, parentPostId: string, postType: RemovePostFromThreadPostTypeEnum, participantPostId: string, options?: AxiosRequestConfig) {
        return ThreadApiFp(this.configuration).removePostFromThread(userId, parentPostId, postType, participantPostId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AddPostToThreadPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type AddPostToThreadPostTypeEnum = typeof AddPostToThreadPostTypeEnum[keyof typeof AddPostToThreadPostTypeEnum];
/**
 * @export
 */
export const GetPostThreadPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type GetPostThreadPostTypeEnum = typeof GetPostThreadPostTypeEnum[keyof typeof GetPostThreadPostTypeEnum];
/**
 * @export
 */
export const RemovePostFromThreadPostTypeEnum = {
    Unspecified: 'POST_TYPE_UNSPECIFIED',
    Post: 'POST_TYPE_POST',
    Repost: 'POST_TYPE_REPOST',
    Question: 'POST_TYPE_QUESTION',
    Achievement: 'POST_TYPE_ACHIEVEMENT',
    Announcement: 'POST_TYPE_ANNOUNCEMENT',
    Poll: 'POST_TYPE_POLL',
    Article: 'POST_TYPE_ARTICLE',
    ShortStory: 'POST_TYPE_SHORT_STORY'
} as const;
export type RemovePostFromThreadPostTypeEnum = typeof RemovePostFromThreadPostTypeEnum[keyof typeof RemovePostFromThreadPostTypeEnum];


/**
 * TopicApi - axios parameter creator
 * @export
 */
export const TopicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client to create a topic
         * @summary Create A Topic
         * @param {string} userId the user ID trying to whom the community is tied to (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} communityProfileId the community profile to associate the topic to | type: uint64
         * @param {Topic} topic topic payload | type: json_object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTopic: async (userId: string, communityProfileId: string, topic: Topic, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createTopic', 'userId', userId)
            // verify required parameter 'communityProfileId' is not null or undefined
            assertParamExists('createTopic', 'communityProfileId', communityProfileId)
            // verify required parameter 'topic' is not null or undefined
            assertParamExists('createTopic', 'topic', topic)
            const localVarPath = `/api/v1/users/{userId}/community/{communityProfileId}/topic`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"communityProfileId"}}`, encodeURIComponent(String(communityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(topic, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to get topics of communities a user follows
         * @summary Get Topics Of Communities User Follows
         * @param {string} userId the user ID whose communities topics follow set we want to obtain (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicsOfCommunitiesUserFollows: async (userId: string, limit: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getTopicsOfCommunitiesUserFollows', 'userId', userId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getTopicsOfCommunitiesUserFollows', 'limit', limit)
            const localVarPath = `/api/v1/users/{userId}/topics`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TopicApi - functional programming interface
 * @export
 */
export const TopicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TopicApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client to create a topic
         * @summary Create A Topic
         * @param {string} userId the user ID trying to whom the community is tied to (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} communityProfileId the community profile to associate the topic to | type: uint64
         * @param {Topic} topic topic payload | type: json_object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTopic(userId: string, communityProfileId: string, topic: Topic, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTopicResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTopic(userId, communityProfileId, topic, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TopicApi.createTopic']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to get topics of communities a user follows
         * @summary Get Topics Of Communities User Follows
         * @param {string} userId the user ID whose communities topics follow set we want to obtain (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicsOfCommunitiesUserFollows(userId: string, limit: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTopicsOfCommunitiesUserFollowsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicsOfCommunitiesUserFollows(userId, limit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TopicApi.getTopicsOfCommunitiesUserFollows']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TopicApi - factory interface
 * @export
 */
export const TopicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TopicApiFp(configuration)
    return {
        /**
         * This endpoint enables a client to create a topic
         * @summary Create A Topic
         * @param {string} userId the user ID trying to whom the community is tied to (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} communityProfileId the community profile to associate the topic to | type: uint64
         * @param {Topic} topic topic payload | type: json_object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTopic(userId: string, communityProfileId: string, topic: Topic, options?: any): AxiosPromise<CreateTopicResponse> {
            return localVarFp.createTopic(userId, communityProfileId, topic, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to get topics of communities a user follows
         * @summary Get Topics Of Communities User Follows
         * @param {string} userId the user ID whose communities topics follow set we want to obtain (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {string} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicsOfCommunitiesUserFollows(userId: string, limit: string, options?: any): AxiosPromise<GetTopicsOfCommunitiesUserFollowsResponse> {
            return localVarFp.getTopicsOfCommunitiesUserFollows(userId, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TopicApi - object-oriented interface
 * @export
 * @class TopicApi
 * @extends {BaseAPI}
 */
export class TopicApi extends BaseAPI {
    /**
     * This endpoint enables a client to create a topic
     * @summary Create A Topic
     * @param {string} userId the user ID trying to whom the community is tied to (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {string} communityProfileId the community profile to associate the topic to | type: uint64
     * @param {Topic} topic topic payload | type: json_object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public createTopic(userId: string, communityProfileId: string, topic: Topic, options?: AxiosRequestConfig) {
        return TopicApiFp(this.configuration).createTopic(userId, communityProfileId, topic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to get topics of communities a user follows
     * @summary Get Topics Of Communities User Follows
     * @param {string} userId the user ID whose communities topics follow set we want to obtain (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {string} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public getTopicsOfCommunitiesUserFollows(userId: string, limit: string, options?: AxiosRequestConfig) {
        return TopicApiFp(this.configuration).getTopicsOfCommunitiesUserFollows(userId, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint performs an updates operation on a user profile based on the provided parametersThis update operation can span multiple services on specific cases (such as when the client is explicitly attempting to update the email of the user)All update operations are atomic by nature hence we should not expect any form of divergent state
         * @summary update a user profile
         * @param {string} userId the user ID trying to update this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {UserProfile} userProfile the profile payload | type: json_object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserProfile: async (userId: string, userProfile: UserProfile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('editUserProfile', 'userId', userId)
            // verify required parameter 'userProfile' is not null or undefined
            assertParamExists('editUserProfile', 'userProfile', userProfile)
            const localVarPath = `/api/v1/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint performs an updates operation on a user profile based on the provided parametersThis update operation can span multiple services on specific cases (such as when the client is explicitly attempting to update the email of the user)All update operations are atomic by nature hence we should not expect any form of divergent state
         * @summary update a user profile
         * @param {string} userId the user ID trying to update this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {UserProfile} userProfile the profile payload | type: json_object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editUserProfile(userId: string, userProfile: UserProfile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditUserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editUserProfile(userId, userProfile, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.editUserProfile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * This endpoint performs an updates operation on a user profile based on the provided parametersThis update operation can span multiple services on specific cases (such as when the client is explicitly attempting to update the email of the user)All update operations are atomic by nature hence we should not expect any form of divergent state
         * @summary update a user profile
         * @param {string} userId the user ID trying to update this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {UserProfile} userProfile the profile payload | type: json_object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserProfile(userId: string, userProfile: UserProfile, options?: any): AxiosPromise<EditUserProfileResponse> {
            return localVarFp.editUserProfile(userId, userProfile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * This endpoint performs an updates operation on a user profile based on the provided parametersThis update operation can span multiple services on specific cases (such as when the client is explicitly attempting to update the email of the user)All update operations are atomic by nature hence we should not expect any form of divergent state
     * @summary update a user profile
     * @param {string} userId the user ID trying to update this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {UserProfile} userProfile the profile payload | type: json_object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public editUserProfile(userId: string, userProfile: UserProfile, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).editUserProfile(userId, userProfile, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserProfileApi - axios parameter creator
 * @export
 */
export const UserProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint enables a client to create a user profile
         * @summary creates a user profile
         * @param {CreateUserProfileRequest} createUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserProfile: async (createUserProfileRequest: CreateUserProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserProfileRequest' is not null or undefined
            assertParamExists('createUserProfile', 'createUserProfileRequest', createUserProfileRequest)
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to delete a user profile
         * @summary deletes a user profile
         * @param {string} userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserProfile: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserProfile', 'userId', userId)
            const localVarPath = `/api/v1/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to discover a set of profiles he/she does not follow
         * @summary Discover Profiles
         * @param {string} userId 
         * @param {string} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverProfiles: async (userId: string, limit: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('discoverProfiles', 'userId', userId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('discoverProfiles', 'limit', limit)
            const localVarPath = `/api/v1/users/{userId}/discover/limit/{limit}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"limit"}}`, encodeURIComponent(String(limit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint performs a query against the social service to obtain a user profile
         * @summary gets a user profile
         * @param {string} userId The user ID associated with the profile we want to get | type: uint64
         * @param {string} [requestorProfileId] The RequestorProfileID is an optional parameter used to check if the profileID (requestor) making a request for the record actually follows the record
         * @param {GetUserProfileRequestorProfileTypeEnum} [requestorProfileType] The RequestorProfileType is an optional parameter which tells us what type of profile is the requestor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfile: async (userId: string, requestorProfileId?: string, requestorProfileType?: GetUserProfileRequestorProfileTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserProfile', 'userId', userId)
            const localVarPath = `/api/v1/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestorProfileId !== undefined) {
                localVarQueryParameter['requestorProfileId'] = requestorProfileId;
            }

            if (requestorProfileType !== undefined) {
                localVarQueryParameter['requestorProfileType'] = requestorProfileType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables a client to get a number of user profiles in a paginated manner
         * @summary Gets a set of user profiles
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfiles: async (pageSize: number, pageNumber: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getUserProfiles', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('getUserProfiles', 'pageNumber', pageNumber)
            const localVarPath = `/api/v1/users/page-size/{pageSize}/page-number/{pageNumber}`
                .replace(`{${"pageSize"}}`, encodeURIComponent(String(pageSize)))
                .replace(`{${"pageNumber"}}`, encodeURIComponent(String(pageNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserProfileApi - functional programming interface
 * @export
 */
export const UserProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint enables a client to create a user profile
         * @summary creates a user profile
         * @param {CreateUserProfileRequest} createUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserProfile(createUserProfileRequest: CreateUserProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserProfile(createUserProfileRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserProfileApi.createUserProfile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to delete a user profile
         * @summary deletes a user profile
         * @param {string} userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserProfile(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteUserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserProfile(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserProfileApi.deleteUserProfile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to discover a set of profiles he/she does not follow
         * @summary Discover Profiles
         * @param {string} userId 
         * @param {string} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discoverProfiles(userId: string, limit: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscoverProfilesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discoverProfiles(userId, limit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserProfileApi.discoverProfiles']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint performs a query against the social service to obtain a user profile
         * @summary gets a user profile
         * @param {string} userId The user ID associated with the profile we want to get | type: uint64
         * @param {string} [requestorProfileId] The RequestorProfileID is an optional parameter used to check if the profileID (requestor) making a request for the record actually follows the record
         * @param {GetUserProfileRequestorProfileTypeEnum} [requestorProfileType] The RequestorProfileType is an optional parameter which tells us what type of profile is the requestor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProfile(userId: string, requestorProfileId?: string, requestorProfileType?: GetUserProfileRequestorProfileTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProfile(userId, requestorProfileId, requestorProfileType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserProfileApi.getUserProfile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint enables a client to get a number of user profiles in a paginated manner
         * @summary Gets a set of user profiles
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProfiles(pageSize: number, pageNumber: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserProfilesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProfiles(pageSize, pageNumber, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserProfileApi.getUserProfiles']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserProfileApi - factory interface
 * @export
 */
export const UserProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserProfileApiFp(configuration)
    return {
        /**
         * This endpoint enables a client to create a user profile
         * @summary creates a user profile
         * @param {CreateUserProfileRequest} createUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserProfile(createUserProfileRequest: CreateUserProfileRequest, options?: any): AxiosPromise<CreateUserProfileResponse> {
            return localVarFp.createUserProfile(createUserProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to delete a user profile
         * @summary deletes a user profile
         * @param {string} userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserProfile(userId: string, options?: any): AxiosPromise<DeleteUserProfileResponse> {
            return localVarFp.deleteUserProfile(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to discover a set of profiles he/she does not follow
         * @summary Discover Profiles
         * @param {string} userId 
         * @param {string} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverProfiles(userId: string, limit: string, options?: any): AxiosPromise<DiscoverProfilesResponse> {
            return localVarFp.discoverProfiles(userId, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint performs a query against the social service to obtain a user profile
         * @summary gets a user profile
         * @param {string} userId The user ID associated with the profile we want to get | type: uint64
         * @param {string} [requestorProfileId] The RequestorProfileID is an optional parameter used to check if the profileID (requestor) making a request for the record actually follows the record
         * @param {GetUserProfileRequestorProfileTypeEnum} [requestorProfileType] The RequestorProfileType is an optional parameter which tells us what type of profile is the requestor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfile(userId: string, requestorProfileId?: string, requestorProfileType?: GetUserProfileRequestorProfileTypeEnum, options?: any): AxiosPromise<GetUserProfileResponse> {
            return localVarFp.getUserProfile(userId, requestorProfileId, requestorProfileType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables a client to get a number of user profiles in a paginated manner
         * @summary Gets a set of user profiles
         * @param {number} pageSize 
         * @param {number} pageNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfiles(pageSize: number, pageNumber: number, options?: any): AxiosPromise<GetUserProfilesResponse> {
            return localVarFp.getUserProfiles(pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserProfileApi - object-oriented interface
 * @export
 * @class UserProfileApi
 * @extends {BaseAPI}
 */
export class UserProfileApi extends BaseAPI {
    /**
     * This endpoint enables a client to create a user profile
     * @summary creates a user profile
     * @param {CreateUserProfileRequest} createUserProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public createUserProfile(createUserProfileRequest: CreateUserProfileRequest, options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).createUserProfile(createUserProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to delete a user profile
     * @summary deletes a user profile
     * @param {string} userId the user ID trying to delete this user profile (NOTE: userID refers to the ID from the vantage point of the user service. This ID is the single source of truth for a given user across our suite of services) | type: uint64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public deleteUserProfile(userId: string, options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).deleteUserProfile(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to discover a set of profiles he/she does not follow
     * @summary Discover Profiles
     * @param {string} userId 
     * @param {string} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public discoverProfiles(userId: string, limit: string, options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).discoverProfiles(userId, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint performs a query against the social service to obtain a user profile
     * @summary gets a user profile
     * @param {string} userId The user ID associated with the profile we want to get | type: uint64
     * @param {string} [requestorProfileId] The RequestorProfileID is an optional parameter used to check if the profileID (requestor) making a request for the record actually follows the record
     * @param {GetUserProfileRequestorProfileTypeEnum} [requestorProfileType] The RequestorProfileType is an optional parameter which tells us what type of profile is the requestor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public getUserProfile(userId: string, requestorProfileId?: string, requestorProfileType?: GetUserProfileRequestorProfileTypeEnum, options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).getUserProfile(userId, requestorProfileId, requestorProfileType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables a client to get a number of user profiles in a paginated manner
     * @summary Gets a set of user profiles
     * @param {number} pageSize 
     * @param {number} pageNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public getUserProfiles(pageSize: number, pageNumber: number, options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).getUserProfiles(pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetUserProfileRequestorProfileTypeEnum = {
    Unspecified: 'ACCOUNT_TYPE_UNSPECIFIED',
    User: 'ACCOUNT_TYPE_USER',
    Community: 'ACCOUNT_TYPE_COMMUNITY'
} as const;
export type GetUserProfileRequestorProfileTypeEnum = typeof GetUserProfileRequestorProfileTypeEnum[keyof typeof GetUserProfileRequestorProfileTypeEnum];


